{==============================================================================\
|                             Draynor Chop N' Bank                             |
|                                 - Includes -                                 |
|==============================================================================|
|                                                                              |
|      Written By: Coh3n                                                       |
|      Description: For any generic functions used throughout the core         |
 \_____________________________________________________________________________}

{.include DCnB_Form.scar}

const
  SCRIPT_VERSION = '50';

  //used for the temporary stats system
  STATS_LINK = 'http://scriptmanager.freehostia.com/submit.php'; //needed to record stats
  STATS_LOGINS  = 1;
  STATS_WILLOWS = 2;
  STATS_OAKS    = 3;
  STATS_LOADS   = 4;
  STATS_BREAKS  = 5;
  STATS_EXP     = 6;
  STATS_LEVELS  = 7;
  STATS_RANDOMS = 8;

  //for all the dtms used in the script
  DTM_HATCHET_NORMAL = 0;
  DTM_HATCHET_DRAGON = 1;

  //represents all the different walking points
  WALK_TREES_WILLOWS    = 0;
  WALK_TREES_OAKS_1     = 1;
  WALK_TREES_OAKS_2     = 2;
  WALK_BANK_WILLOWS     = 3;
  WALK_BANK_OAKS_1      = 4;
  WALK_BANK_OAKS_2      = 5;
  WALK_BANK_RELOCATE    = 6;
  WALK_WILLOWS_RELOCATE = 7;

  //all the walking paths
  PATH_BANK_TO_WILLOWS = 0;
  PATH_BANK_TO_OAKS    = 1;
  PATH_OAKS_TO_BANK    = 2;
  PATH_WILLOWS_TO_BANK = 3;

  //different types of mouse clicks
  CLICK_LEFT  = 1;
  CLICK_RIGHT = 2;
  HOVER       = 3;

  //used in the autocoloring functions
  MM_ROAD    = 0;
  MM_BANK    = 1;
  MM_DUNGEON = 2;

  //used for all the main screen objects
  OBJ_TREE       = 0;
  OBJ_BANK_BOOTH = 1;

  //used for the debugging specifics
  DEBUG_ERROR   = 0;
  DEBUG_SUCCESS = 1;
  DEBUG_DETAILS = 2;
  DEBUG_PLAYER  = 3;

//stores the necessary information for objects found on the main screen
type
  TMSObject = record
    name: String;
    upText: TStringArray;
    color, width, height, minLen, tol, dtm: Integer;
    hueMod, satMod, exp: Extended;
  end;

var
  tP: TPoint;                      //used as the tree tracking point
  srl_MMTPA: TPointArray;          //used in autocoloring
  playerLoads, totalLogs: Integer; //used for breaking
  falseReason: Array of String;    //holds reasons why players are inactive
  hasLoggedIn: Array of Boolean;   //used to check if the player has been logged in or not

  //used in the stats system
  Stats_UserID, Stats_Password, Stats_ScriptID: String;
  Stats_LastTime: Integer;
  Stats_CustomVars: Array [1..20] of Integer;

procedure Debug(proc, msg: String; debugLevel: Integer);
begin
  case debugLevel of
    DEBUG_ERROR:
      Writeln('-> ERROR: ' + proc + ': ' + msg);

    DEBUG_SUCCESS:
      Writeln('-> SUCCESS: ' + proc + ': ' + msg);

    DEBUG_DETAILS:
      Writeln('-> DETAIL: ' + proc + ': ' + msg);

    DEBUG_PLAYER:
      Writeln('-> PLAYER: ' + Capitalize(Players[CurrentPlayer].Name) + ': ' + proc + ': ' + msg);

    else
      Debug('DCnB_Debug', 'Invalid debug choice', DEBUG_ERROR);
  end;
end;

{******************************************************************************}
{ procedure Stats_CheckOutput(s: string);                                      }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
procedure Stats_CheckOutput(s: string);
var
  i: Integer;
  sa: TStringArray;
begin
  sa := Explode(#10, s);
  for i := 0 to High(sa) do
    if (Trim(sa[i]) <> '') then
      if StartsWith('ERROR(1)', sa[i]) then
      begin
        WriteLn('STATS: "' + sa[i] + '"');
        Stats_UserID := '';
        Stats_Password := '';
      end
      else if StartsWith('ERROR(2)', sa[i]) then
      begin
        WriteLn('STATS: "' + sa[i] + '"');
        Stats_ScriptID := '';
      end
      else
        WriteLn('STATS: "' + sa[i] + '"');
end;

{******************************************************************************}
{ procedure Stats_GetScriptInfo( ... );                                        }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
function Stats_GetScriptInfo(out Version, News, Link: string;
         out OutDated: Boolean; out LastUpdate_HoursAgo: Integer): Boolean;
var
  Client: Integer;
  s: string;
  sa: TStringArray;
begin
  Result := False;
  if (Stats_ScriptID = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'getinfo');
  AddPostVariable (Client, 'sID', Stats_ScriptID);

  s := PostHTTPPageEx(Client, STATS_LINK);
  sa := Explode(#10'GLUE'#10, s);
  if (Length(sa) = 5) then
  begin
    Result := True;
    Version := sa[0];
    News := sa[1];
    Link := sa[2];
    OutDated := sa[3] = '1';
    LastUpdate_HoursAgo := StrToIntDef(sa[4], -1);
  end
  else
    Stats_CheckOutput(s);

  FreeHTTPClient(Client );
end;

{******************************************************************************}
{ procedure Stats_SendReport;                                                  }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
var
  Stats_GlobalVars: array[1..24] of Integer;

procedure Stats_SendReport;
var
  i, Client, Time: Integer;
  s: string;
begin
  if (Stats_UserID = '') and (Stats_Password = '') and (Stats_ScriptID = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'submit');

  Time := (GetTimeRunning - Stats_LastTime) div 1000 div 60;
  if (Time < 5) then
    Time := 0
  else
    Stats_LastTime := GetTimeRunning;
  AddPostVariable(Client, 'sTime', IntToStr(Time));

  if (Stats_UserID <> '') and (Stats_Password <> '') then
  begin
    AddPostVariable(Client, 'uID', Stats_UserID);
    AddPostVariable(Client, 'uPass', Stats_Password);
  end
  else
  begin
    AddPostVariable(Client, 'uID', '-1');
    AddPostVariable(Client, 'uPass', '');
  end;

  if (Stats_ScriptID <> '') then
  begin
    AddPostVariable (Client, 'sID', Stats_ScriptID);

    for i := Low(Stats_CustomVars) to High(Stats_CustomVars) do
    begin
      AddPostVariable(Client, 'rndCustom' + IntToStr(i),
                      IntToStr(Stats_CustomVars[i]));
      Stats_CustomVars[i] := 0;
    end;
  end
  else
  begin
    AddPostVariable (Client, 'sID', '-1');
  end;

  for i := Low(Stats_GlobalVars) to High(Stats_GlobalVars) do
  begin
    case i of
      1: s := IntToStr(SRL_Logs - Stats_GlobalVars[i]);
      2: s := IntToStr(Banks - Stats_GlobalVars[i]);
      3: s := IntToStr(RandSolved[rand_Death] - Stats_GlobalVars[i]);
      else if ((i - 3) < Length(RandSolved) - 1) then
        s := IntToStr(RandSolved[i - 3] - Stats_GlobalVars[i]);
    end;
    AddPostVariable(Client, 'rndGlobal' + IntToStr(i), s);
    Stats_GlobalVars[i] := Stats_GlobalVars[i] + StrToInt(s);
  end;

  s := PostHTTPPageEx(Client, STATS_LINK);
  Stats_CheckOutput(s);
  FreeHTTPClient(Client);

  if (SRL_Procs[srl_OnSendStats] <> nil) then
    SRL_Procs[srl_OnSendStats]();
end;

{******************************************************************************}
{ procedure Stats_SendAccountInfo;                                             }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
procedure Stats_SendAccountInfo;
var
  i, Client: Integer;
  Accounts: TStringArray;
begin
  if (Stats_UserID = '') and (Stats_Password = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'setaccounts');
  AddPostVariable(Client, 'uID', Stats_UserID);
  AddPostVariable(Client, 'uPass', Stats_Password);
  if (Stats_ScriptID <> '') then
    AddPostVariable (Client, 'sID', Stats_ScriptID)
  else
    AddPostVariable (Client, 'sID', '-1');

  SetLength(Accounts, HowManyPlayers);
  for i := 0 to HowManyPlayers - 1 do
    Accounts[i] := Implode('.|€stat€|.', [Players[i].Name, Players[i].Loc,
                   IntToStr(Integer(Players[i].Active))]);

  AddPostVariable(Client, 'accInfo', Implode(#10'ACC'#10, Accounts));
  Stats_CheckOutput(PostHTTPPageEx(Client, STATS_LINK));
  FreeHTTPClient(Client);
end;

{******************************************************************************}
{ procedure Stats_ManageAccounts;                                              }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
procedure Stats_ManageAccounts;
var
  i, ii, Client: Integer;
  s: string;
  Accounts, Stats: TStringArray;
begin
  if (Stats_UserID = '') and (Stats_Password = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'getaccounts');
  AddPostVariable(Client, 'uPass', Stats_Password);
  AddPostVariable(Client, 'uID', Stats_UserID);

  s := PostHTTPPageEx(Client, STATS_LINK);
  Accounts := Explode(#10'ACC'#10, s);
  for i := 0 to High(Accounts) do
  begin
    Stats := Explode('.|€stat€|.', Accounts[i]);
    if (Length(Stats) = 3) then
    begin
      for ii := 0 to HowManyPlayers - 1 do
        if (LowerCase(Players[ii].Name) = LowerCase(Stats[0])) then
        begin
          Players[ii].Loc := Stats[1];
          Players[ii].Active := Stats[2] = '1';
          Break;
        end;
    end
    else
    begin
      Stats_CheckOutput(s);
      Break;
    end;
  end;

  FreeHTTPClient(Client);
  stats_SendAccountInfo;
end;

procedure Stats_Send;
begin
  Debug('Stats_Send', 'Sending stats to the server...', DEBUG_DETAILS);
  Stats_SendReport;
  Stats_ManageAccounts;
end;

{******************************************************************************}
{ function AC_CircleTPA(cX, cY, r: Integer): TPointArray;                      }
{ By: Nava2                                                                    }
{ Description: Creates a TPA of a circle with radius 'r' and center point      }
{              cX, cY                                                          }
{******************************************************************************}
function CircleTPA(cX, cY, r: Integer): TPointArray;
var
  i, j, l, tX, tY: Integer;
begin
  setLength(Result, 4 * r * r);
  l := 2 * r - 1;
  tX := cX - r;
  tY := cY - r;
  for i := 0 to l do
    for j := 0 to l do
      Result[j + l * i] := Point(tX + i, tY + j);

  Result := RemoveDistTPointArray(cX, cY, r, Result, True);
end;

{******************************************************************************}
{ function AC_ReturnMMTPA: TPointArray;                                        }
{ By: Nava2                                                                    }
{ Description: Performs AC_CircleTPA for the RS minimap                        }
{******************************************************************************}
function ReturnMMTPA: TPointArray;
begin
  if High(srl_MMTPA) < 0 then
  begin
    Result := CircleTPA(MMCX, MMCY, (MMX2 - MMX1) div 2);
    srl_MMTPA := Result;
  end else
    Result := srl_MMTPA;
end;

procedure Signature;
begin
  ClearDebug;
  Writeln('                                            ___          ');
  Wait(100);
  Writeln('                       ____                /\__\         ');
  Wait(100);
  Writeln('                      /\___\     ____      \/ _/         ');
  Wait(100);
  Writeln('       _____          \/_  /    /\___\      \/ _____     ');
  Wait(100);
  Writeln('      /\____\  _______/ / /___ _\/___ \_____  /\____\    ');
  Wait(100);;
  Writeln('     / /  ___\/\______\/ /____\\____/ /_____\/ / ____\   ');
  Wait(100);
  Writeln('    / /  /__ / / ___  / ____  //___  / ____  \/ /___\    ');
  Wait(100);
  Writeln('   / /  /___\ / /__/ / / / / /____/ / /  / / /____  /    ');
  Wait(100);
  Writeln('   \/_______//______/_/ /_/_/______/_/__/_/_/____/ /     ');
  Wait(100);
  Writeln('                             \/___________________/      ');
  Wait(100);
  Writeln(PadR('               Draynor Chop N'' Bank ~ Revision ' + SCRIPT_VERSION + '!', 57));
end;

procedure Antiban;
begin
  case Random(100) of
    10: BoredHuman;
    20: HoverSkill('random', False);
    30: HoverSkill('woodcutting', False);
    40: PickUpMouse;
    50: RandomRClick;
    60: RandomMovement;
    70: SleepAndMoveMouse(200 + Random(50));
    90: ExamineInv;
  end;
end;

procedure Randoms(waitFrom, waitTo: Integer);
begin
  if (not LoggedIn) then
    Exit;

  LampSkill := 'Woodcutting';
  //Debug('Find_Randoms', 'Scanning for random events...', DEBUG_DETAILS);

  //checks to see if the player as gained a level
  if (LevelUp) then
  begin
    Inc(Players[CurrentPlayer].Integers[P_LEVELS]);
    Inc(Stats_CustomVars[STATS_LEVELS]);
    Stats_Send;
  end;

  //checks for randoms
  if (FindNormalRandoms) then
  begin
    Inc(Stats_CustomVars[STATS_RANDOMS]);
    Stats_Send;

    //plays sound if specified to do so
    if (playSnd) then
      PlaySound(ScriptPath + 'RandomSound.wav');
  end;

  UseRewardBox;
  Wait(RandomRange(waitFrom, waitTo)); //to reduce lag on some computers
end;

{******************************************************************************}
{ function Report_GroupDigits(n: integer; token: String): String;              }
{ By: PriSoner and Nava2                                                       }
{ Description: Formats an integer into groups of 3 seperated by `token' and    }
{              returns a formatted string (i.e 1234567 would become 1,234,567) }
{******************************************************************************}
function GroupDigits(n: integer; token: String): String;
var
  b: integer;
begin
  Result := IntToStr(n);
  b := length(Result) + 1;
  if b > 3 then
  repeat
    b := b - 3;
    if b > 1 then
      insert(token, Result, b);
  until (b < 3);
end;

procedure AddToProggy(s: String);
begin
  {$IFDEF SIMBA}
    Writeln(s);
  {$ELSE}
    AddToReport(s);
  {$ENDIF}
end;