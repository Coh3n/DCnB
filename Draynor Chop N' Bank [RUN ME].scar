{==============================================================================\
|                             Draynor Chop N' Bank                             |
|                               - Revision 46 -                                |
|==============================================================================|
|                                                                              |
|      Written By: Coh3n                                                       |
|      Description: Cuts Willow/Oak trees in Draynor and banks the logs        |
|      Contact Info: Private message via Villavu.com                           |
|                                                                              |
|      Many more scripts of various types can be found at VillaVu.com!         |
 \_____________________________________________________________________________}
 
{==============================================================================\
|                              Setup Instructions                              |
|==============================================================================]
|                                                                              |
|       1. Determine whether or not you're using SMART (line 51)               |
|       2. Determine whether or not you're using the PlayerForm (line 55)      |
|       3. Have hatchet in FIRST inventory slot or equipped                    |
|       4. Start in Draynor bank                                               |
|       5. Setup player(s) via DeclarePlayers/PlayerForm                       |
|       6. Hit run/start script                                                |
|       7. Post any progress reports and/or bugs!                              |
 \_____________________________________________________________________________}
 
{==============================================================================\
|                                   Features                                   |
|==============================================================================|
|                                                                              |
|     * Custom PlayerForm             * AntiRandoms/Antiban                    |
|     * Custom signature              * Supports hatchets up to Dragon         |
|     * Detailed progress report      * Efficient tree finding/banking         |
|     * Breaking/player switching     * Detects and records levels gained      |
|     * Supports Oaks/Willows         * Plus many more!                        |
|     * Unlimited number of players                                            |
 \_____________________________________________________________________________}
 
{==============================================================================|
|                                    Credits                                   |
|==============================================================================|
|                                                                              |
|     * Nava2 -> for the autocoloring functions                                |
|     * Zeph -> for all the help and putting up with my noobish questions      |
|     * Markus -> for the same reasons as Zeph                                 |
|     * Rasta Magician -> for creating the headers                             |
|     * nielsie95 -> for the temprary stats system and script code             |
|     * Everyone who helped me on the forums/IRC                               |
|     * Everyone who has posted progress reports and/or bugs                   |
 \_____________________________________________________________________________}

program DraynorChopNBank;
{.include SRL/SRL/misc/Smart.scar} //Add '//' to the beginning of the line to disable SMART
{.include DCnB_Form.scar}

const
  USE_FORM = True; // <-- VERY IMPORTANT! True = use PlayerForm
  SCRIPT_VERSION = '46';
   
  //used for the temporary stats system
  STATS_LINK = 'http://scriptmanager.freehostia.com/submit.php'; //needed to record stats
  STATS_LOGINS  = 1;
  STATS_WILLOWS = 2;
  STATS_OAKS    = 3;
  STATS_LOADS   = 4;
  STATS_BREAKS  = 5;
  STATS_EXP     = 6;
  STATS_LEVELS  = 7;
  STATS_RANDOMS = 8;

  //for all the dtms used in the script
  DTM_HATCHET_NORMAL = 0;
  DTM_HATCHET_DRAGON = 1;

  //represents all the different walking points
  WALK_TREES_WILLOWS = 0;
  WALK_TREES_OAKS_1  = 1;
  WALK_TREES_OAKS_2  = 2;
  WALK_BANK_WILLOWS  = 3;
  WALK_BANK_OAKS_1   = 4;
  WALK_BANK_OAKS_2   = 5;
  WALK_BANK_RELOCATE = 6;
  
  //all the walking paths
  PATH_BANK_TO_WILLOWS = 0;
  PATH_BANK_TO_OAKS    = 1;
  PATH_OAKS_TO_BANK    = 2;
  PATH_WILLOWS_TO_BANK = 3;

  //different types of mouse clicks
  CLICK_LEFT  = 1;
  CLICK_RIGHT = 2;
  HOVER       = 3;

  //used in the autocoloring functions
  MM_ROAD    = 0;
  MM_BANK    = 1;
  MM_DUNGEON = 2;
  
  //used for all the main screen objects
  OBJ_TREE       = 0;
  OBJ_BANK_BOOTH = 1;
    
  //used for the debugging specifics
  DEBUG_ERROR   = 0;
  DEBUG_SUCCESS = 1;
  DEBUG_DETAILS = 2;
  DEBUG_PLAYER  = 3;

//stores the necessary information for objects found on the main screen
type
  TMSObject = record
    name: String;
    upText: TStringArray;
    color, width, height, minLen, tol, dtm: Integer;
    hueMod, satMod, exp: Extended;
  end;

var
  tP: TPoint;                     //used as the tree tracking point
  srl_MMTPA: TPointArray;         //used in autocoloring
  breakAfterLoads: Integer;       //used for breaking
  falseReason: Array of String;   //holds reasons why players are inactive
  hasLoggedIn: Array of Boolean;  //determines whether the player has been logged in yet

  //used in the stats system
  Stats_UserID, Stats_Password, Stats_ScriptID: String;
  Stats_LastTime: Integer;
  Stats_CustomVars: Array [1..20] of Integer;

{==============================================================================\
|                               Script Setup                                   |
|==============================================================================|
|                                                                              |
|    * To setup the script if you decided NOT to use the player form           |
|    * Setup from here to line 264                                             |
 \_____________________________________________________________________________}
 

const
  //for the different SMART settings
  SMART_WORLD          = 152;   //world to load
  SMART_MEMBERS_WORLD  = False; //True = Members world

  STATS_ID   = '';      //your SRL Stats ID
  STATS_PASS = '';      //your SRL Stats Password
  
  RANDOM_SOUND = False; //True = a sound plays when a random is found
  BREAK_AFTER  = 15;    //loads until break/switch player
  
procedure DeclarePlayers;
begin
  HowManyPlayers := 1;
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0;
  SetLength(falseReason, HowManyPlayers);
  
  with Players[0] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';   //3-4 LOWERCASE letters from your username
    Active := True; //True = use this player
    Pin    := '';   //leave blank if you don't have a bank pin
    Integers[P_TOTAL_LOGS]  := 000;  //total logs to cut
    Booleans[P_TAKE_BREAKS] := True; //True = the player will take breaks
    Booleans[P_EQUIPPED]    := True; //True = your hatchet is equipped
    Strings[P_TREE]         := '';   //either 'willow' or 'oak'
  end;

{  // <-- Remove the curly braces to use multiple players!

  with Players[1] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
  
  with Players[2] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;

  with Players[3] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
  
  with Players[4] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
  
  with Players[5] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
//}
end;

{******************************************************************************}
{ procedure Stats_CheckOutput(s: string);                                      }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
procedure Stats_CheckOutput(s: string);
var
  i: Integer;
  sa: TStringArray;
begin
  sa := Explode(#10, s);
  for i := 0 to High(sa) do
    if (Trim(sa[i]) <> '') then
      if StartsWith('ERROR(1)', sa[i]) then
      begin
        WriteLn('STATS: "' + sa[i] + '"');
        Stats_UserID := '';
        Stats_Password := '';
      end
      else if StartsWith('ERROR(2)', sa[i]) then
      begin
        WriteLn('STATS: "' + sa[i] + '"');
        Stats_ScriptID := '';
      end
      else
        WriteLn('STATS: "' + sa[i] + '"');
end;

{******************************************************************************}
{ procedure Stats_GetScriptInfo( ... );                                        }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
function Stats_GetScriptInfo(out Version, News, Link: string;
         out OutDated: Boolean; out LastUpdate_HoursAgo: Integer): Boolean;
var
  Client: Integer;
  s: string;
  sa: TStringArray;
begin
  Result := False;
  if (Stats_ScriptID = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'getinfo');
  AddPostVariable (Client, 'sID', Stats_ScriptID);

  s := PostHTTPPageEx(Client, STATS_LINK);
  sa := Explode(#10'GLUE'#10, s);
  if (Length(sa) = 5) then
  begin
    Result := True;
    Version := sa[0];
    News := sa[1];
    Link := sa[2];
    OutDated := sa[3] = '1';
    LastUpdate_HoursAgo := StrToIntDef(sa[4], -1);
  end
  else
    Stats_CheckOutput(s);

  FreeHTTPClient(Client );
end;

{******************************************************************************}
{ procedure Stats_SendReport;                                                  }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
var
  Stats_GlobalVars: array[1..24] of Integer;

procedure Stats_SendReport;
var
  i, Client, Time: Integer;
  s: string;
begin
  if (Stats_UserID = '') and (Stats_Password = '') and (Stats_ScriptID = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'submit');

  Time := (GetTimeRunning - Stats_LastTime) div 1000 div 60;
  if (Time < 5) then
    Time := 0
  else
    Stats_LastTime := GetTimeRunning;
  AddPostVariable(Client, 'sTime', IntToStr(Time));

  if (Stats_UserID <> '') and (Stats_Password <> '') then
  begin
    AddPostVariable(Client, 'uID', Stats_UserID);
    AddPostVariable(Client, 'uPass', Stats_Password);
  end
  else
  begin
    AddPostVariable(Client, 'uID', '-1');
    AddPostVariable(Client, 'uPass', '');
  end;

  if (Stats_ScriptID <> '') then
  begin
    AddPostVariable (Client, 'sID', Stats_ScriptID);

    for i := Low(Stats_CustomVars) to High(Stats_CustomVars) do
    begin
      AddPostVariable(Client, 'rndCustom' + IntToStr(i),
                      IntToStr(Stats_CustomVars[i]));
      Stats_CustomVars[i] := 0;
    end;
  end
  else
  begin
    AddPostVariable (Client, 'sID', '-1');
  end;

  for i := Low(Stats_GlobalVars) to High(Stats_GlobalVars) do
  begin
    case i of
      1: s := IntToStr(SRL_Logs - Stats_GlobalVars[i]);
      2: s := IntToStr(Banks - Stats_GlobalVars[i]);
      3: s := IntToStr(RandSolved[rand_Death] - Stats_GlobalVars[i]);
      else if ((i - 3) < Length(RandSolved) - 1) then
        s := IntToStr(RandSolved[i - 3] - Stats_GlobalVars[i]);
    end;
    AddPostVariable(Client, 'rndGlobal' + IntToStr(i), s);
    Stats_GlobalVars[i] := Stats_GlobalVars[i] + StrToInt(s);
  end;

  s := PostHTTPPageEx(Client, STATS_LINK);
  Stats_CheckOutput(s);
  FreeHTTPClient(Client);

  if (SRL_Procs[srl_OnSendStats] <> nil) then
    SRL_Procs[srl_OnSendStats]();
end;

{******************************************************************************}
{ procedure Stats_SendAccountInfo;                                             }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
procedure Stats_SendAccountInfo;
var
  i, Client: Integer;
  Accounts: TStringArray;
begin
  if (Stats_UserID = '') and (Stats_Password = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'setaccounts');
  AddPostVariable(Client, 'uID', Stats_UserID);
  AddPostVariable(Client, 'uPass', Stats_Password);
  if (Stats_ScriptID <> '') then
    AddPostVariable (Client, 'sID', Stats_ScriptID)
  else
    AddPostVariable (Client, 'sID', '-1');

  SetLength(Accounts, HowManyPlayers);
  for i := 0 to HowManyPlayers - 1 do
    Accounts[i] := Implode('.|€stat€|.', [Players[i].Name, Players[i].Loc,
                   IntToStr(Integer(Players[i].Active))]);

  AddPostVariable(Client, 'accInfo', Implode(#10'ACC'#10, Accounts));
  Stats_CheckOutput(PostHTTPPageEx(Client, STATS_LINK));
  FreeHTTPClient(Client);
end;

{******************************************************************************}
{ procedure Stats_ManageAccounts;                                              }
{ By: nielsie95                                                                }
{ Description:                                                                 }
{******************************************************************************}
procedure Stats_ManageAccounts;
var
  i, ii, Client: Integer;
  s: string;
  Accounts, Stats: TStringArray;
begin
  if (Stats_UserID = '') and (Stats_Password = '') then
    Exit;

  Client := InitializeHTTPClient(False, False);
  ClearPostData(Client);
  AddPostVariable(Client, 'do', 'getaccounts');
  AddPostVariable(Client, 'uPass', Stats_Password);
  AddPostVariable(Client, 'uID', Stats_UserID);

  s := PostHTTPPageEx(Client, STATS_LINK);
  Accounts := Explode(#10'ACC'#10, s);
  for i := 0 to High(Accounts) do
  begin
    Stats := Explode('.|€stat€|.', Accounts[i]);
    if (Length(Stats) = 3) then
    begin
      for ii := 0 to HowManyPlayers - 1 do
        if (LowerCase(Players[ii].Name) = LowerCase(Stats[0])) then
        begin
          Players[ii].Loc := Stats[1];
          Players[ii].Active := Stats[2] = '1';
          Break;
        end;
    end
    else
    begin
      Stats_CheckOutput(s);
      Break;
    end;
  end;

  FreeHTTPClient(Client);
  stats_SendAccountInfo;
end;

{******************************************************************************}
{ function AC_CircleTPA(cX, cY, r: Integer): TPointArray;                      }
{ By: Nava2                                                                    }
{ Description: Creates a TPA of a circle with radius 'r' and center point      }
{              cX, cY                                                          }
{******************************************************************************}
function AC_CircleTPA(cX, cY, r: Integer): TPointArray;
var
  i, j, l, tX, tY: Integer;
begin
  setLength(Result, 4 * r * r);
  l := 2 * r - 1;
  tX := cX - r;
  tY := cY - r;
  for i := 0 to l do
    for j := 0 to l do
      Result[j + l * i] := Point(tX + i, tY + j);

  Result := RemoveDistTPointArray(cX, cY, r, Result, True);
end;

{******************************************************************************}
{ function AC_ReturnMMTPA: TPointArray;                                        }
{ By: Nava2                                                                    }
{ Description: Performs AC_CircleTPA for the RS minimap                        }
{******************************************************************************}
function AC_ReturnMMTPA: TPointArray;
begin
  if High(srl_MMTPA) < 0 then
  begin
    Result := AC_CircleTPA(MMCX, MMCY, (MMX2 - MMX1) div 2);
    srl_MMTPA := Result;
  end else
    Result := srl_MMTPA;
end;

procedure DCnB_Signature;
begin
  ClearDebug;
  Writeln('                                            ___          ');
  Wait(100);
  Writeln('                       ____                /\__\         ');
  Wait(100);
  Writeln('                      /\___\     ____      \/ _/         ');
  Wait(100);
  Writeln('       _____          \/_  /    /\___\      \/ _____     ');
  Wait(100);
  Writeln('      /\____\  _______/ / /___ _\/___ \_____  /\____\    ');
  Wait(100);;
  Writeln('     / /  ___\/\______\/ /____\\____/ /_____\/ / ____\   ');
  Wait(100);
  Writeln('    / /  /__ / / ___  / ____  //___  / ____  \/ /___\    ');
  Wait(100);
  Writeln('   / /  /___\ / /__/ / / / / /____/ / /  / / /____  /    ');
  Wait(100);
  Writeln('   \/_______//______/_/ /_/_/______/_/__/_/_/____/ /     ');
  Wait(100);
  Writeln('                             \/___________________/      ');
  Wait(100);
  Writeln(PadR('               Draynor Chop N'' Bank ~ Revision ' + SCRIPT_VERSION + '!', 57));
end;

procedure DCnB_Debug(proc, msg: String; debug: Integer);
begin
  case debug of
    DEBUG_ERROR:
      Writeln('-> ERROR: ' + proc + ': ' + msg);
      
    DEBUG_SUCCESS:
      Writeln('-> SUCCESS: ' + proc + ': ' + msg);
      
    DEBUG_DETAILS:
      Writeln('-> DETAIL: ' + proc + ': ' + msg);
      
    DEBUG_PLAYER:
      Writeln('-> PLAYER: ' + Capitalize(Players[CurrentPlayer].Name) + ': ' + proc + ': ' + msg);
      
    else
      DCnB_Debug('DCnB_Debug', 'Invalid debug choice', DEBUG_ERROR);
  end;
end;

procedure Load_Antiban;
begin
  case Random(100) of
    10: BoredHuman;
    20: HoverSkill('random', False);
    30: HoverSkill('woodcutting', False);
    40: PickUpMouse;
    50: RandomRClick;
    60: RandomMovement;
    70: SleepAndMoveMouse(200 + Random(50));
    90: ExamineInv;
  end;
end;

function Load_MSObject(which: Integer): TMSObject;
begin
  case which of
    OBJ_TREE:
      case Lowercase(Players[CurrentPlayer].Strings[P_TREE]) of
        'oak':
          with Result do
          begin
            name   := 'Oak tree';
            upText := ['Oak'];
            color  := 4425336;
            width  := 60;
            height := 60;
            minLen := 100;
            hueMod := 0.06;
            satMod := 0.77;
            exp    := 37.5;
            tol    := 9;
            dtm    := DTMFromString('78DA63AC676160B06662400629DE3A0CFC409' +
                        'A11CA67AC05AA714355C3C000E1C3D59402D53813505302546349' +
                        '404D1D508D1101359D40358604D4F401D5D81150D30154E3885F0' +
                        'D00C2F8071A');
          end;

        'willow':
          with Result do
          begin
            name   := 'Willow tree';
            upText := ['Willow', 'Wil', 'llow', 'low'];
            color  := 4481105;
            width  := 60;
            height := 60;
            minLen := 20;
            hueMod := 0.18;
            satMod := 0.28;
            exp    := 67.5;
            tol    := 14;
            dtm    := DTMFromString('78DA636C636660D8C9C8800CCC0D0519F8813' +
                        '44C94B105A8E608AA1A060626881C4C4D0550CD4122D4EC20A0A6' +
                        '09A866230135BD4035EB08A8998CE92F0C355D403587F0AB0100D' +
                        '71D0ABD');
          end;

        else
          DCnB_Debug('Load_MSObject', 'Invalid tree type in DeclarePlayers', DEBUG_ERROR);
      end;
      
    OBJ_BANK_BOOTH:
      with Result do
      begin
        name   := 'Bank booth';
        upText := ['Bank booth', 'ank boo', 'ooth'];
        color  := 6909561;
        width  := 30;
        height := 30;
        minLen := 80;
        hueMod := 0.45;
        satMod := 0.50;
        tol    := 7;
        dtm    := DTMFromString('78DA636C636660D8C9C8800CCC0D0519F8813' +
                    '44C94B105A8E608AA1A060626881C4C4D0550CD4122D4EC20A0A6' +
                    '09A866230135BD4035EB08A8998CE92F0C355D403587F0AB0100D' +
                    '71D0ABD');
      end;
      
    else
      DCnB_Debug('Load_MSObject', 'Invalid object index', DEBUG_ERROR);
  end;
end;

function Level_Gained: Boolean;
var
  i, t: Integer;
  chatText: TStringArray;
  p: TPoint;
begin
  if (not LoggedIn) then
    Exit;
  
  chatText := ['ongrat', 'dvanced', 'ulatio', 'oodcuti'];
  for i := 0 to High(chatText) do
  begin
    if (FindNPCChatText(chatText[i], Nothing)) then
    begin
      ClickContinue(True, True);
      Result := True;
      Break;
    end;
  end;
            
  if (Result) then
  begin
    Inc(Stats_CustomVars[STATS_LEVELS]);
    Stats_SendReport;
    Stats_ManageAccounts;
    
    DCnB_Debug('Level_Gained', 'Congratulations, you have gained a Woodcutting level!', DEBUG_PLAYER);
    GameTab(tab_Stats);
    p := SkillToCoords(skill_Woodcutting);
    Mouse(p.x, p.y, 3, 0, True);
    
    t := GetSystemTime + 5000;
    while (GetSystemTime < t) do
      if (GetColor(449, 50) = 8042720) then //the skill info X
      begin
        Mouse(449, 50, 3, 3, True);
        Break;
      end;

    Wait(RandomRange(250, 750));
    GameTab(tab_Inv);
  end;
end;

procedure Next_Player(active: Boolean; proc, msg: String);
begin
  if (BankScreen) then
    CloseBank;
    
  if (not active) then
  begin
    DCnB_Debug(proc, msg, DEBUG_PLAYER);
    Players[CurrentPlayer].Loc := 'Lost';
    DCnB_Debug('Next_Player', 'Location - ' + Players[CurrentPlayer].Loc, DEBUG_PLAYER);
    falseReason[CurrentPlayer] := msg;
  end else
    DCnB_Debug(proc, msg, DEBUG_DETAILS);
  
  Logout; //just an extra precaution
  NextPlayer(active);
  breakAfterLoads := 0;
  
  if (AllPlayersInactive) then
  begin
    DCnB_Debug('Next_Player', 'All players inactive', DEBUG_SUCCESS);
    TerminateScript;
  end;
end;

procedure Next_Break;
begin
  if (not LoggedIn) then
    Exit;
  Inc(Stats_CustomVars[STATS_BREAKS]);

  with Players[CurrentPlayer] do
    Integers[P_BREAKS] := Integers[P_BREAKS] + 1;
    
  if (HowManyPlayers > 1) then
    Next_Player(True, 'Next_Break', 'Switching players...')
  else
  begin
    DCnB_Debug('Next_Break', 'Taking a short break...', DEBUG_DETAILS);
    Logout;
    Wait(RandomRange(780000, 1020000)); // 15 +/- random 2 minutes
    
    DCnB_Debug('Next_Break', 'Break over, logging back in...', DEBUG_DETAILS);
    LoginPlayer;
  end;
  
  Inc(Stats_CustomVars[STATS_LOGINS]);
  Stats_SendReport;
  Stats_ManageAccounts;
end;

procedure Find_Randoms(waitFrom, waitTo: Integer);
begin
  if (not LoggedIn) then
    Exit;
    
  LampSkill := 'Woodcutting';
  DCnB_Debug('Find_Randoms', 'Scanning for random events...', DEBUG_DETAILS);

  if (Level_Gained) then
    Inc(Players[CurrentPlayer].Integers[P_LEVELS]);
    
  if (FindNormalRandoms) then
  begin
    Inc(Stats_CustomVars[STATS_RANDOMS]);
    Stats_SendReport;
    Stats_ManageAccounts;
    
    if (playSnd) then
      PlaySound(ScriptPath + 'RandomSound.wav');
  end;

  UseRewardBox;
  Wait(RandomRange(waitFrom, waitTo));
end;

function Find_Object(var x, y: Integer; which: Integer): Boolean;
var
  notFindObj, notFindUptext, i: Integer;
  obj: TMSObject;
  pts: TPointArray;
  boxes: T2DPointArray;
begin
  if (not LoggedIn) then
    Exit;
  obj := Load_MSObject(which);
  notFindObj := 0;
  notFindUptext := 0;

  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(obj.hueMod, obj.satMod);

  repeat
    FindColorsSpiralTolerance(MSCX, MSCY, pts, obj.color, MSX1, MSY1, MSX2, MSY2, obj.tol);
    boxes := TPAToATPAEx(pts, obj.width, obj.height);
    //DebugATPA(boxesArr, '');
    DCnB_Debug('Find_Object', obj.name + ' - boxes found: ' + IntToStr(Length(boxes)), DEBUG_DETAILS);

    if (Length(boxes) <= 0) then
    begin
      DCnB_Debug('Find_Object', 'Failed to find object: ' + obj.name, DEBUG_ERROR);
      Find_Randoms(2000, 4000);
      Inc(notFindObj);
    end;

    SortATPAFrom(boxes, Point(MSCX, MSCY));
    for i := 0 to High(boxes) do
    begin
      if (Length(boxes[i]) < obj.minLen) then
      begin
        Find_Randoms(50, 150);
        Continue;
      end;

      MiddleTPAEx(boxes[i], x, y);
      MMouse(x, y, 4, 4);
      notFindObj := 0;

      Result := WaitUptextMulti(obj.upText, 500);
      if (Result) then
      begin
        DCnB_Debug('Find_Object', 'Found object: ' + obj.name, DEBUG_SUCCESS);
        notFindUptext := 0;
        Break;
      end else begin
        DCnB_Debug('Find_Object', 'Failed to find uptext for object: ' + obj.name, DEBUG_ERROR);
        Inc(notFindUptext);
      end;

    end;
  until(Result or (not LoggedIn) or (notFindUptext >= 55) or (notFindObj >= 55));

  if (notFindObj >= 55) then
    Next_Player(False, 'Find_Object', 'Failed to find object: ' + obj.name + ' 55 times');

  if (notFindUptext >= 55) then
    Next_Player(False, 'Find_Object', 'Failed to find uptext: ' + obj.name + ' 55 times');

  SetColorSpeed2Modifiers(0.2, 0.2);
  ColorToleranceSpeed(1);
  FreeDTM(obj.dtm);
end;

function Find_Hatchet: Boolean;
var
  x, y, h, i: Integer;
  dtm_Hatchet: Array[0..1] of Integer;
begin
  if (not LoggedIn) then
    Exit;
  
  dtm_Hatchet[DTM_HATCHET_NORMAL] :=
    DTMFromString('78DA639CC0C2C0709D910119E4050830F0036' +
       '990E87F2060EC07AAB98FAA868181094CC244197B816AEE105003' +
       'B2EB22013553806A2EE3570300C2B90C0B');

  dtm_Hatchet[DTM_HATCHET_DRAGON] :=
    DTMFromString('78DA63CC66666058C7C8800CFC05B819A6016' +
       '99828630A50CD6A54350C0C4C1039989A02A09A5504D41401D5AC' +
       '21A0260DA8661301352540355BF0AB0100FB0307CF');

  if (Players[CurrentPlayer].Booleans[P_EQUIPPED]) then
    GameTab(tab_Equip)
  else
    GameTab(tab_Inv);

  h := High(dtm_Hatchet);
  for i := 0 to h do
  begin
    Result := FindDTM(dtm_Hatchet[i], x, y, MIX1, MIY1, MIX2, MIY2);
    if Result then
      Break;
  end;
  
  FreeDTM(dtm_Hatchet[DTM_HATCHET_NORMAL]);
  FreeDTM(dtm_Hatchet[DTM_HATCHET_DRAGON]);
end;

{******************************************************************************}
{ function AutoColorFunction: Integer;                                         }
{ By: Nava2, edited by Coh3n                                                   }
{ Description: Finds best color on the minimap, depending on the RGB ranges    }
{******************************************************************************}
function Find_MMColors(Which: Integer): Integer;
var
  R, G, B, minR, maxR, minG, maxG, minB, maxB: Integer;
  i, h, c, curMax, j: Integer;
  t: TPointArray;
  CycleCols, newCols, colorCounts: TIntegerArray;
begin
  Result := -1;
  
  case Which of
    MM_ROAD:
      begin
        minR := 73; maxR := 100;
        minG := 75; maxG := 100;
        minB := 72; maxB := 97;
      end;
      
    MM_BANK:
      begin
        minR := 49; maxR := 63;
        minG := 51; maxG := 64;
        minB := 47; maxB := 60;
      end;
      
    MM_DUNGEON:
      begin
        minR := 240; maxR := 252;
        minG := 42;  maxG := 160;
        minB := 42;  maxB := 160;
      end;
      
    else
      DCnB_Debug('Find_MMColors', 'Invalid Color parameters', DEBUG_ERROR);
  end;
  
  //Get all the colours in the minimap
  CycleCols := GetColors(AC_ReturnMMTPA);
  ClearSameIntegers(CycleCols);

  //Cycle through creating a new array based on the inputted RGB max/mins
  h := High(CycleCols);
  setLength(newCols, h + 1);
  for i := 0 to h do
  begin
    ColorToRGB(CycleCols[i], R, G, B);
    if (InRange(R, minR, maxR) and InRange(G, minG, maxG)
        and InRange(B, minB, maxB)) then
    begin
      newCols[c] := CycleCols[i];
      Inc(c);
    end;
  end;

  setLength(newCols, c);
  setLength(colorCounts, c);
  Dec(c);

  {
    Use the colour which is most common. Could be substituted to use other
    means to pick the right colour post-RGB checks. (Density, TPA spread, etc.)
  }
  for i := 0 to c do
  begin
    FindColors(t, newCols[i], MMX1, MMY1, MMX2, MMY2);
    h := Length(t);
    if (h > curMax) then
    begin
      j := i;
      curMax := h;
    end;
  end;

  if (Length(newCols) > 0) then
  begin
    Result := newCols[j];
    DCnB_Debug('Find_MMColors', 'Found Color: ' + IntToStr(Result), DEBUG_SUCCESS);
  end else
    DCnB_Debug('Find_MMColors', 'Failed to find color: ' + IntToStr(Which), DEBUG_DETAILS);
end;

function Chop_IsTreeDown: Boolean;
var
  inBox: TPointArray;
  tree: TMSObject;
begin
  if not LoggedIn or InvFull then Exit;
  tree := Load_MSObject(OBJ_TREE);
  
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(tree.hueMod, tree.satMod);
  
  FindColorsTolerance(inBox, tree.Color, tP.x - 15, tP.y - 15, tP.x + 15,
                                         tP.y + 15, tree.tol);
  Result := (Length(inBox) < 20);
  DCnB_Debug('Chop_IsTreeDown', 'Length inside Box: ' + IntToStr(Length(inBox)), DEBUG_DETAILS);
  
  if (Result) then
    DCnB_Debug('Chop_IsTreeDown', 'Tree has been cut down!', DEBUG_DETAILS);
  
  SetColorSpeed2Modifiers(0.2, 0.2);
  ColorToleranceSpeed(1);
  FreeDTM(tree.dtm);
end;

function Chop_Trees: Boolean;
var
  t, x, y: Integer;
begin
  if (not LoggedIn) then
    Exit;

  repeat
    if (InvFull) then
      Break;

    if (Find_Object(x, y, OBJ_TREE)) then
    begin
      Mouse(x, y, 0, 0, True);
      Wait(RandomRange(2000, 3000));

      GetMousePos(x, y);
      tP := IntToPoint(x, y);
      DCnB_Debug('Chop_Trees', 'Track Point: (' + IntToStr(x) + ', ' + IntToStr(y) + ')', DEBUG_DETAILS);

      t := GetSystemTime + RandomRange(15000, 20000);
      repeat
        if (Level_Gained) then
          Inc(Players[CurrentPlayer].Integers[P_LEVELS]);

        Result := Chop_IsTreeDown;
        if (Result or (GetSystemTime > t)) then
          Break;

        Load_Antiban;
        Find_Randoms(500, 1000);
      until(InvFull or (not LoggedIn));
    end;
  until(InvFull or (not LoggedIn));
end;

function Walk_ConstToLoc(which: Integer): String;
begin
  case which of
    WALK_TREES_WILLOWS:
      Result := 'Willows';

    WALK_TREES_OAKS_1:
      Result := 'Oaks[1]';

    WALK_TREES_OAKS_2:
      Result := 'Oaks';

    WALK_BANK_WILLOWS, WALK_BANK_OAKS_2, WALK_BANK_RELOCATE:
      Result := 'Bank';

    WALK_BANK_OAKS_1:
      Result := 'Bank[1]';

    else
      DCnB_Debug('Walk_ConstToLoc', 'Invalid location', DEBUG_ERROR);
  end;
end;

function Walk_WaitWhile(where: Integer): Boolean;
var
  t: Integer;
begin
  t := GetSystemTime + 10000;
  while (GetSystemTime < t) do
  begin
    Find_Randoms(1500, 3000);

    if (FFlag(5) or (not IsMoving)) then
    begin
      Players[CurrentPlayer].Loc := Walk_ConstToLoc(where);
      DCnB_Debug('Walk_WaitWhile', 'Location - ' + Players[CurrentPlayer].Loc, DEBUG_PLAYER);
      Wait(RandomRange(500, 1000));
      Result := True;
      Break;
    end;
  end;
end;

function Walk_PerformIndex(which: Integer): Boolean;
var
  dungeonColor, bankColor, x, y: Integer;
begin
  if (not LoggedIn) then
    Exit;

  MakeCompass('n');
  RunEnergy(20);

  case which of
    WALK_TREES_WILLOWS:
      MouseBox(595, 113, 613, 130, CLICK_LEFT);

    WALK_TREES_OAKS_1:
      begin
        roadColor := Find_MMColors(MM_ROAD);
        if (not RadialWalkTolerance(roadColor, 85, 105, 60, 2, 1, 10)) then
          MouseBox(672, 85, 983, 97, CLICK_LEFT);
      end;

    WALK_TREES_OAKS_2:
      if (FindSymbolIn(x, y, 'dungeon', MMCX, MMY1, MMX2, MMY2)) then
        Mouse(x - Random(3), y - 15, 3, 3, True)
      else begin
        dungeonColor := Find_MMColors(MM_DUNGEON);
        if (not RadialWalkTolerance(dungeonColor, 65, 95, 60, -2, 15, 10)) then
          MouseBox(669, 55, 678, 63, CLICK_LEFT);
      end;

    WALK_BANK_WILLOWS:
      MouseBox(645, 44, 656, 53, CLICK_LEFT);

    WALK_BANK_OAKS_1:
      begin
        roadColor := Find_MMColors(MM_ROAD);
        if (not RadialWalkTolerance(roadColor, 275, 240, 70, 2, 1, 10)) then
          MouseBox(569, 87, 578, 96, CLICK_LEFT);
      end;

    WALK_BANK_OAKS_2:
      begin
        bankColor := Find_MMColors(MM_BANK);
        if (not RadialWalkTolerance(bankColor, 295, 240, 70, 2, 1, 10)) then
          if (FindSymbolIn(x, y, 'bank', MMX1, MMY1, MMCX, MMY2)) then
            Mouse(x, y, 3, 3, True)
          else
            MouseBox(566, 101, 582, 112, CLICK_LEFT);
      end;
      
    WALK_BANK_RELOCATE:
      if (FindSymbolIn(x, y, 'bank', MMX1, MMY1, MMCX, MMY2)) then
        Mouse(x, y, 3, 3, True);

    else
      DCnB_Debug('Walk_PerformIndex', 'Invalid walk point', DEBUG_ERROR);
  end;

  Result := Walk_WaitWhile(which);
  if (Result) then
    DCnB_Debug('Walk_PerformIndex', 'Walked to location: ' + Walk_ConstToLoc(which), DEBUG_SUCCESS)
  else
    Next_Player(False, 'Walk_PerformIndex', 'Failed to walk to location: ' + Walk_ConstToLoc(which));
end;

function Walk_ToLoc(where: Integer): Boolean;
begin
  case where of
    PATH_BANK_TO_WILLOWS:
      if (Players[CurrentPlayer].Loc = 'Bank') then
        Result := Walk_PerformIndex(WALK_TREES_WILLOWS)
      else
        Result := True;

    PATH_WILLOWS_TO_BANK:
      if (Players[CurrentPlayer].Loc = 'Willows') then
        Result := Walk_PerformIndex(WALK_BANK_WILLOWS)
      else
        Result := True;

    PATH_BANK_TO_OAKS:
      case Players[CurrentPlayer].Loc of
        'Bank':
          if (Walk_PerformIndex(WALK_TREES_OAKS_1)) then
            Result := Walk_PerformIndex(WALK_TREES_OAKS_2);
            
        'Oaks[1]':
          Result := Walk_PerformIndex(WALK_TREES_OAKS_2);
          
        'Oaks':
          Result := True;
          
        else
          DCnB_Debug('Walk_ToLoc', 'Invalid location for PATH_BANK_TO_OAKS', DEBUG_ERROR);
      end;

    PATH_OAKS_TO_BANK:
      case Players[CurrentPlayer].Loc of
        'Oaks':
          if (Walk_PerformIndex(WALK_BANK_OAKS_1)) then
            Result := Walk_PerformIndex(WALK_BANK_OAKS_2);
            
        'Bank[1]':
          Result := Walk_PerformIndex(WALK_BANK_OAKS_2);
          
        'Bank':
          Result := True;

        else
          DCnB_Debug('Walk_ToLoc', 'Invalid location for PATH_OAKS_TO_BANK', DEBUG_ERROR);
      end;

    else
      DCnB_Debug('Walk_ToLoc', 'Invalid walk path', DEBUG_ERROR);
  end;

  if (Result) then
    DCnB_Debug('Walk_ToLoc', 'Walked to ' + Walk_ConstToLoc(where), DEBUG_SUCCESS);
end;

function Bank_Open: Boolean;
var
  t, x, y: Integer;
begin
  if (not LoggedIn) then
    Exit;

  t := GetSystemTime + 10000;
  repeat
    if (Find_Object(x, y, OBJ_BANK_BOOTH)) then
    begin
      Mouse(x, y, 0, 0, False);

      if (WaitOptionEx('uick', 'Action',  ClickLeft, 500)) then
      begin
        Result := WaitFunc(@BankScreen, 50,  3000);
        if (not Result) then
          Result := WaitFunc(@PinScreen, 50, 3000);
      end else
        DCnB_Debug('Bank_Open', 'Failed to choose option: Use-quickly', DEBUG_ERROR);
    end else
      Walk_PerformIndex(WALK_BANK_RELOCATE);
  until(Result or (not LoggedIn) or (GetSystemTime > t));

  if (Result) then
    if (PinScreen) then
    begin
      InPin(Players[CurrentPlayer].Pin);
      Result := WaitFunc(@BankScreen, 50, 3000);
    end;
end;

function Bank_Logs: Boolean;
var
  logsInInv, t: Integer;
  tree: TMSObject;
begin
  if (not LoggedIn) or (InvCount <= 1) then
    Exit;
  tree := Load_MSObject(OBJ_TREE);

  if (Bank_Open) then
  begin
    DCnB_Debug('Bank_Logs', 'Successfully opened bank!', DEBUG_SUCCESS);
    Wait(RandomRange(500, 1000));

    //count the logs in inventory
    logsInInv := CountItems('dtm', tree.dtm, []);
    if (logsInInv > 0) then
      DCnB_Debug('Bank_Logs', 'Found ' + IntToStr(logsInInv) + ' logs in inventory', DEBUG_DETAILS)
    else
      DCnB_Debug('Bank_Logs', 'Failed to find dtm: ' + tree.name, DEBUG_ERROR);

    //deposit the logs
    if (Players[CurrentPlayer].Booleans[P_EQUIPPED]) then
      MouseBox(386, 300, 409, 315, CLICK_LEFT)
    else
      Deposit(2, 28, True);

    //waits for the logs to leave the inv (in case of lag)
    t := GetSystemTime + 5000;
    while (GetSystemTime < t) do
    begin
      Wait(RandomRange(200, 500));
      if (InvCount <= 1) then
      begin
        Result := True;
        Break;
      end;
    end;

  end else
    DCnB_Debug('Bank_Logs', 'Failed to open bank', DEBUG_ERROR);

  if (Result) then
  begin
    DCnB_Debug('Bank_Logs', 'Successfully banked logs!', DEBUG_SUCCESS);
    Wait(RandomRange(250, 750));
    Inc(breakAfterLoads);

    //randomly closes the bank, or just walks to the trees
    if (Random(10) > 4) then
      CloseBank;

    //add the necessary info to the progress report
    IncEx(Players[CurrentPlayer].Integers[P_EXP], Round(logsInInv * tree.exp));
    IncEx(Players[CurrentPlayer].Integers[P_LOGS], logsInInv);
    Inc(Players[CurrentPlayer].Integers[P_LOADS]);

    //send the necessary info to the stats server
    if (tree.name = 'Willow') then
      IncEx(Stats_CustomVars[STATS_WILLOWS], logsInInv)
    else
      IncEx(Stats_CustomVars[STATS_OAKS], logsInInv);
    IncEx(Stats_CustomVars[STATS_EXP], Round(logsInInv * tree.exp));
    Inc(Stats_CustomVars[STATS_LOADS]);
    Stats_SendReport;
    Stats_ManageAccounts;

    with Players[CurrentPlayer] do
      if (Integers[P_LOGS] >= Integers[P_TOTAL_LOGS]) then
        Next_Player(False, 'Bank_Logs', 'Cut desired number of logs');
  end;

  FreeDTM(tree.dtm);
end;

{******************************************************************************}
{ function Report_GroupDigits(n: integer; token: String): String;              }
{ By: PriSoner and Nava2                                                       }
{ Description: Formats an integer into groups of 3 seperated by `token' and    }
{              returns a formatted string (i.e 1234567 would become 1,234,567) }
{******************************************************************************}
function Report_GroupDigits(n: integer; token: String): String;
var
  b: integer;
begin
  Result := IntToStr(n);
  b := length(Result) + 1;
  if b > 3 then
  repeat
    b := b - 3;
    if b > 1 then
      insert(token, Result, b);
  until (b < 3);
end;

function Report_GetTotals: TStringArray;
var
  i: Integer;
  temp: TIntegerArray;
begin
  SetLength(temp, 5);
  SetLength(Result, Length(temp));
  
  for i := 0 to High(Players) do
    with Players[i] do
    begin
      IncEx(temp[0], Integers[P_LOADS]);
      IncEx(temp[1], Integers[P_LOGS]);
      IncEx(temp[2], Integers[P_LEVELS]);
      IncEx(temp[3], Integers[P_EXP]);
      IncEx(temp[4], Integers[P_BREAKS]);
    end;
    
  for i := 0 to High(temp) do
    Result[i] := Report_GroupDigits(temp[i], ',');
end;

procedure Report_AddTo(s: String);
begin
  {$IFDEF SIMBA}
    Writeln(s);
  {$ELSE}
    AddToReport(s);
  {$ENDIF}
end;

procedure Report_WhichProgram(right: Integer);
var
  theRunTime, theProgram, useSMART: String;
begin
  theRunTime := 'Ran For: ' + TimeRunning;
  
  {$IFDEF SIMBA}
    theProgram := 'Simba';
  {$ELSE}
    theProgram := 'SCAR';
  {$ENDIF}
  
  {$IFDEF SRL_SMART}
    useSMART := 'Yes';
  {$ELSE}
    useSMART := 'No';
  {$ENDIF}
  
  if (HowManyPlayers = 1) then
  begin
    Report_AddTo(PadR('|    Program: ' + theProgram, right) + '|');
    Report_AddTo(PadR('|    SMART:   ' + useSMART, right) + '|');
    Report_AddTo(PadR('|    ' + theRunTime, right) + '|');
  end else
  begin
    Report_AddTo(PadR('|                    ' + theRunTime, right) + '|');
    Report_AddTo(PadR('|                             Program: ' + theProgram +
                      ' | SMART: ' + useSMART, right) + '|');
  end;
end;

procedure Report_MultiPlayer;
var
  i: Integer;
  s: TStringArray;
begin
  s := Report_GetTotals;
  Report_AddTo('/=====================================================================================|'); //86
  Report_AddTo(PadR('|                         Coh3n''s Draynor Chop N'' Bank!', 86) + '|');
  Report_AddTo(PadR('|                                - Revision ' + SCRIPT_VERSION + ' -', 86) + '|');
  Report_AddTo('|=====================================================================================|');
  Report_AddTo('|                                                                                     |');
  Report_WhichProgram(86);
  Report_AddTo('|______ ________ __________ _______ ________ __________ ________ ____________ ________|');
  Report_AddTo('| Nick | Active | Location | Loads |  Tree  | Logs Cut | Levels | Experience | Breaks |');
  Report_AddTo('|¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯|');

  //adds all the player info to the report
  for i := 0 to High(Players) do
    with Players[i] do
      Report_AddTo('| ' + PadR(Nick, 5) + '| ' + PadR(BoolToStr(Active), 7) + '| '
                        + PadR(Loc, 9) + '|  ' + PadR(Report_GroupDigits(Integers[P_LOADS], ','), 5) + '| '
                        + PadR(Capitalize(Strings[P_TREE]), 7) + '|  ' + PadR(Report_GroupDigits(Integers[P_LOGS], ','), 8) + '|   '
                        + PadR(IntToStr(Integers[P_LEVELS]), 5) + '|  ' + PadR(Report_GroupDigits(Integers[P_EXP], ','), 10) + '|   '
                        + PadR(IntToStr(Integers[P_BREAKS]), 5) + '|');

  Report_AddTo('|-------------------------------------------------------------------------------------|');
  Report_AddTo(PadR('| Totals:', 27) + '|  ' + PadR(s[0], 5) + '|        |  ' + PadR(s[1], 8) + '|   '
                    + PadR(s[2], 5) + '|  ' + PadR(s[3], 10) + '|   ' + PadR(s[4], 5) + '|');
                    
  Report_AddTo('|                                                                                     |');
  Report_AddTo('| False Reasons:                                                                      |');
  
  //adds the false reasons to the report
  for i := 0 to High(Players) do
    if (not Players[i].Active) then
      Report_AddTo(PadR('|   ' + Players[i].Nick + ': ' + falseReason[i], 86) + '|');
      
  Report_AddTo('|_____________________________________________________________________________________|');
  Report_AddTo('|_____________________________________________________________________________________/');
end;
  
procedure Report_SinglePlayer;
begin
  Report_AddTo('/====================================================|');
  Report_AddTo(PadR('|           Coh3n''s Draynor Chop N'' Bank!', 53) + '|');
  Report_AddTo('|                  - Revision ' + SCRIPT_VERSION + ' -                   |');
  Report_AddTo('|====================================================|');
  Report_AddTo('|                                                    |');
  Report_WhichProgram(53);
  Report_AddTo('|                                                    |');
  
  with Players[CurrentPlayer] do
  begin
    Report_AddTo(PadR('|    Player:   ' + Capitalize(Name), 53) + '|');
    Report_AddTo(PadR('|    Active:   ' + BoolToStr(Active), 53) + '|');
    Report_AddTo(PadR('|    Location: ' + Capitalize(Loc), 53) + '|');
    if (not Active) then
      Report_AddTo(PadR('|    Reason:   ' + falseReason[CurrentPlayer], 53) + '|');
      
    Report_AddTo(PadR('|      Tree Type:  ' + Capitalize(Strings[P_TREE]), 53) + '|');
    Report_AddTo(PadR('|      Loads Done: ' + Report_GroupDigits(Integers[P_LOADS], ','), 53) + '|');
    Report_AddTo(PadR('|      Logs Cut:   ' + Report_GroupDigits(Integers[P_LOGS], ','), 53) + '|');
    Report_AddTo(PadR('|      Levels Up:  ' + IntToStr(Integers[P_LEVELS]), 53) + '|');
    Report_AddTo(PadR('|      Experience: ' + Report_GroupDigits(Integers[P_EXP], ','), 53) + '|');
    Report_AddTo(PadR('|      Breaks:     ' + IntToStr(Integers[P_BREAKS]), 53) + '|');
  end;

  Report_AddTo('|____________________________________________________|');
  Report_AddTo('|____________________________________________________/');
end;

procedure Report_Print;
var
  i: Integer;
begin
  if (HowManyPlayers = 1) then
    Report_SinglePlayer
  else
    Report_MultiPlayer;
    
  for i := P_LOADS to P_BREAKS do
    if (Players[CurrentPlayer].Integers[i] > 0) then
      Players[CurrentPlayer].Integers[i] := Players[CurrentPlayer].Integers[i]
    else
      Players[CurrentPlayer].Integers[i] := 0;
end;

procedure Setup_Player;
begin
  LoginPlayer;
  Inc(Stats_CustomVars[STATS_LOGINS]);
  Stats_SendReport;
  Stats_ManageAccounts;
  
  Players[CurrentPlayer].Loc := 'Bank';
  hasLoggedIn[CurrentPlayer] := True;
  SetAngle(True);
  Find_Randoms(250, 500);
  
  if (Find_Hatchet) then
    DCnB_Debug('Setup_Player', 'Found hatchet!', DEBUG_SUCCESS)
  else
    Next_Player(False, 'Find_Hatchet', 'Failed to find hatchet');
end;

procedure Setup_Script;
var
  i: Integer;
begin
  {$IFDEF SIMBA}
    ClearDebug;
    Writeln('Thank you for using Draynor Chop N'' Bank - Simba version!');
  {$ELSE}
    DCnB_Signature;
  {$ENDIF}
  
  if (USE_FORM) then
  begin
    tabCount := 1;
    SetLength(formPlayers, tabCount);

    frm_ShowPlayerForm;
    frm_KillForm;
    
    Stats_UserID := statsID;
    Stats_Password := statsPass;

    if (not startReady) then
      TerminateScript;
  end else
  
  begin
    Smart_Server := SMART_WORLD;
    Smart_Members := SMART_MEMBERS_WORLD;
    Smart_Signed := True;
    Smart_SuperDetail := False;
    
    Stats_UserID := STATS_ID;
    Stats_Password := STATS_PASS;
    playSnd := RANDOM_SOUND;
    breakAfter := BREAK_AFTER;
  end;
  
  Stats_ScriptID := '24';
  SetupSRL;
  ActivateClient;
  
  if (not USE_FORM) then
    DeclarePlayers;
  Disguise('Logs Chopped: 0');
  Writeln('Loading, please wait...');
  SymbolAccuracy := 0.5;
  
  SetLength(falseReason, HowManyPlayers);
  SetLength(hasLoggedIn, HowManyPlayers);
  for i := 0 to High(Players) do
  with Players[i] do
  begin
    falseReason[i] := '';
    BoxRewards := ['amp', 'mote', 'ostume', 'oins', 'unes', 're', 'ems'];
    Loc := 'Bank';
  end;
end;

procedure Setup_MainLoop;
var
  totalLogs, i: Integer;
begin
  Setup_Script;
  
  repeat
    with Players[CurrentPlayer] do
      repeat
        if (not hasLoggedIn[CurrentPlayer]) then
          Setup_Player;
      
        if (Lowercase(Strings[P_TREE]) = 'willow') then
          Walk_ToLoc(PATH_BANK_TO_WILLOWS)
        else
          Walk_ToLoc(PATH_BANK_TO_OAKS);

        while (not InvFull) and (LoggedIn) do
          Chop_Trees;

        if (InvFull) then
          if (Lowercase(Strings[P_TREE]) = 'willow') then
            Walk_ToLoc(PATH_WILLOWS_TO_BANK)
          else
            Walk_ToLoc(PATH_OAKS_TO_BANK);

        if (Bank_Logs) then
        begin
          {$IFDEF SIMBA}
            DCnB_Debug('Setup_MainLoop', 'Sorry, no randoms report for Simba :(', DEBUG_DETAILS);
          {$ELSE}
            SRLRandomsReport;
          {$ENDIF}
          Report_Print;
          
          for i := 0 to High(Players) do
            IncEx(totalLogs, Players[i].Integers[P_LOGS]);
            
          Disguise('Logs Chopped: ' + IntToStr(totalLogs));
          totalLogs := 0;
          
          if (Booleans[P_TAKE_BREAKS]) then
            if (breakAfterLoads >= (breakAfter + RandomRange(-2, 2))) then
            begin
              Next_Break;
              breakAfterLoads := 0;
            end;
        end;
      until((Integers[P_LOGS] >= Integers[P_TOTAL_LOGS]) or (not LoggedIn));
    
    if (not LoggedIn) then
      Next_Player(True, 'Setup_MainLoop', 'Switching players');
  until(AllPlayersInactive);
end;

procedure ScriptTerminate;
begin
  Report_Print;
end;

begin
  Setup_MainLoop;
end.

{==============================================================================\
|                    Copyright ©09-10 Coh3n @ SRL-Forums                       |
|==============================================================================}
