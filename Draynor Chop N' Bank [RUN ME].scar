{==============================================================================\
|                             Draynor Chop N' Bank                             |
|                               - Revision 48 -                                |
|==============================================================================|
|                                                                              |
|      Written By: Coh3n                                                       |
|      Description: Cuts Willow/Oak trees in Draynor and banks the logs        |
|      Contact Info: Private message via Villavu.com                           |
|                                                                              |
|      Many more scripts of various types can be found at VillaVu.com!         |
 \_____________________________________________________________________________}
 
{==============================================================================\
|                              Setup Instructions                              |
|==============================================================================]
|                                                                              |
|       1. Determine whether or not you're using SMART (line 51)               |
|       2. Determine whether or not you're using the PlayerForm (line 55)      |
|       3. Have hatchet in FIRST inventory slot or equipped                    |
|       4. Start in Draynor bank                                               |
|       5. Setup player(s) via DeclarePlayers/PlayerForm                       |
|       6. Hit run/start script                                                |
|       7. Post any progress reports and/or bugs!                              |
 \_____________________________________________________________________________}
 
{==============================================================================\
|                                   Features                                   |
|==============================================================================|
|                                                                              |
|     * Custom PlayerForm             * AntiRandoms/Antiban                    |
|     * Custom signature              * Supports hatchets up to Dragon         |
|     * Detailed progress report      * Efficient tree finding/banking         |
|     * Breaking/player switching     * Detects and records levels gained      |
|     * Supports Oaks/Willows         * Plus many more!                        |
|     * Unlimited number of players                                            |
 \_____________________________________________________________________________}
 
{==============================================================================|
|                                    Credits                                   |
|==============================================================================|
|                                                                              |
|     * Nava2 -> for the autocoloring functions                                |
|     * Zeph -> for all the help and putting up with my noobish questions      |
|     * Markus -> for the same reasons as Zeph                                 |
|     * Rasta Magician -> for creating the headers                             |
|     * nielsie95 -> for the temprary stats system and script code             |
|     * Everyone who helped me on the forums/IRC                               |
|     * Everyone who has posted progress reports and/or bugs                   |
 \_____________________________________________________________________________}

program DraynorChopNBank;
{.include SRL/SRL/misc/Smart.scar} //Add '//' to the beginning of the line to disable SMART
{.include DCnB_Includes.scar}

const
  USE_FORM = True; // <-- VERY IMPORTANT! True = use PlayerForm

{==============================================================================\
|                               Script Setup                                   |
|==============================================================================|
|                                                                              |
|    * To setup the script if you decided NOT to use the player form           |
|    * Setup from here to line 264                                             |
 \_____________________________________________________________________________}
 
  //for the different SMART settings
  SMART_WORLD          = 152;   //world to load
  SMART_MEMBERS_WORLD  = False; //True = Members world

  STATS_ID   = '';      //your SRL Stats ID
  STATS_PASS = '';      //your SRL Stats Password
  
  RANDOM_SOUND = False; //True = a sound plays when a random is found
  BREAK_AFTER  = 15;    //loads until break/switch player
  
procedure DeclarePlayers;
begin
  HowManyPlayers := 1;
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0;
  SetLength(falseReason, HowManyPlayers);
  
  with Players[0] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';   //3-4 LOWERCASE letters from your username
    Active := True; //True = use this player
    Pin    := '';   //leave blank if you don't have a bank pin
    Integers[P_TOTAL_LOGS]  := 000;  //total logs to cut
    Booleans[P_TAKE_BREAKS] := True; //True = the player will take breaks
    Booleans[P_EQUIPPED]    := True; //True = your hatchet is equipped
    Strings[P_TREE]         := '';   //either 'willow' or 'oak'
  end;

{  // <-- Remove the curly braces to use multiple players!

  with Players[1] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
  
  with Players[2] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;

  with Players[3] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
  
  with Players[4] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
  
  with Players[5] do
  begin
    Name   := '';
    Pass   := '';
    Nick   := '';
    Active := True;
    Pin    := '';
    Integers[P_TOTAL_LOGS]  := 000;
    Booleans[P_TAKE_BREAKS] := True;
    Booleans[P_EQUIPPED]    := True;
    Strings[P_TREE]         := '';
  end;
//}
end;

function Load_MSObject(which: Integer): TMSObject;
begin
  case which of
    OBJ_TREE:
      case Lowercase(Players[CurrentPlayer].Strings[P_TREE]) of
        'oak':
          with Result do
          begin
            name   := 'Oak tree';
            upText := ['Oak'];
            color  := 4425336;
            width  := 60;
            height := 60;
            minLen := 100;
            hueMod := 0.06;
            satMod := 0.77;
            exp    := 37.5;
            tol    := 9;
            dtm    := DTMFromString('78DA63AC676160B06662400629DE3A0CFC409' +
                        'A11CA67AC05AA714355C3C000E1C3D59402D53813505302546349' +
                        '404D1D508D1101359D40358604D4F401D5D81150D30154E3885F0' +
                        'D00C2F8071A');
          end;

        'willow':
          with Result do
          begin
            name   := 'Willow tree';
            upText := ['Willow', 'Wil', 'llow', 'low'];
            color  := 4481105;
            width  := 60;
            height := 60;
            minLen := 20;
            hueMod := 0.18;
            satMod := 0.28;
            exp    := 67.5;
            tol    := 14;
            dtm    := DTMFromString('78DA636C636660D8C9C8800CCC0D0519F8813' +
                        '44C94B105A8E608AA1A060626881C4C4D0550CD4122D4EC20A0A6' +
                        '09A866230135BD4035EB08A8998CE92F0C355D403587F0AB0100D' +
                        '71D0ABD');
          end;

        else
          Debug('Load_MSObject', 'Invalid tree type in DeclarePlayers', DEBUG_ERROR);
      end;
      
    OBJ_BANK_BOOTH:
      with Result do
      begin
        name   := 'Bank booth';
        upText := ['Bank booth', 'ank boo', 'ooth'];
        color  := 6909561;
        width  := 30;
        height := 30;
        minLen := 80;
        hueMod := 0.45;
        satMod := 0.50;
        tol    := 7;
        dtm    := DTMFromString('78DA636C636660D8C9C8800CCC0D0519F8813' +
                    '44C94B105A8E608AA1A060626881C4C4D0550CD4122D4EC20A0A6' +
                    '09A866230135BD4035EB08A8998CE92F0C355D403587F0AB0100D' +
                    '71D0ABD');
      end;
      
    else
      Debug('Load_MSObject', 'Invalid object index', DEBUG_ERROR);
  end;
end;

procedure Next_Player(active: Boolean; proc, msg: String);
begin
  if (BankScreen) then
    CloseBank;
    
  if (not active) then
  begin
    Debug(proc, msg, DEBUG_PLAYER);
    Players[CurrentPlayer].Loc := 'Lost';
    Debug('Next_Player', 'Location - ' + Players[CurrentPlayer].Loc, DEBUG_PLAYER);
    falseReason[CurrentPlayer] := msg;
  end else
    Debug(proc, msg + ', logging out...', DEBUG_DETAILS);
  
  Logout; //just an extra precaution
  NextPlayer(active);
  playerLoads := 0;
  
  if (AllPlayersInactive) then
  begin
    Debug('Next_Player', 'All players inactive, terminating...', DEBUG_SUCCESS);
    TerminateScript;
  end;
end;

procedure Next_Break;
begin
  if (not LoggedIn) then
    Exit;
    
  //adds to stats/players array
  Inc(Stats_CustomVars[STATS_BREAKS]);
  Inc(Players[CurrentPlayer].Integers[P_BREAKS]);
    
  if (HowManyPlayers > 1) then
    Next_Player(True, 'Next_Break', 'Switching players...')
  else
  begin
    Debug('Next_Break', 'Taking a short break...', DEBUG_DETAILS);
    Logout;
    Wait(RandomRange(780000, 1020000)); // 15 +/- random 2 minutes
    
    Debug('Next_Break', 'Break over, logging back in...', DEBUG_DETAILS);
    LoginPlayer;
  end;
  
  Inc(Stats_CustomVars[STATS_LOGINS]);
  Stats_Send;
end;

function Find_HoverObj(var x, y: Integer; which: Integer): Boolean;
var
  i: Integer;
  obj: TMSObject;
  pts: TPointArray;
  boxes: T2DPointArray;
begin
  obj := Load_MSObject(which);
  if (not LoggedIn) then
    Exit;

  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(obj.hueMod, obj.satMod);

  FindColorsSpiralTolerance(MSCX, MSCY, pts, obj.color, MSX1, MSY1, MSX2, MSY2, obj.tol);
  boxes := TPAToATPAEx(pts, obj.width, obj.height);
  DebugATPA(boxes, '');

  if (Length(boxes) <= 0) then
  begin
    Debug('Find_HoverObj', 'Failed to find object: ' + obj.name, DEBUG_ERROR);
    Randoms(2000, 4000);
  end;

  SortATPAFrom(boxes, Point(MSCX, MSCY));
  for i := 0 to High(boxes) do
  begin
    if (Length(boxes[i]) < obj.minLen) then
    begin
      Randoms(50, 150);
      Continue;
    end;

    MiddleTPAEx(boxes[i], x, y);
    MMouse(x, y, 4, 4);

    if (WaitUptextMulti(obj.upText, 500)) then
    begin
      Debug('Find_HoverObj', 'Found object: ' + obj.name, DEBUG_SUCCESS);
      Result := True;
      Break;
    end else
      Debug('Find_HoverObj', 'Failed to find uptext for object: ' + obj.name, DEBUG_ERROR);
  end;

  SetColorSpeed2Modifiers(0.2, 0.2);
  ColorToleranceSpeed(1);
  FreeDTM(obj.dtm);
end;

function Find_Hatchet: Boolean;
var
  x, y, h, i: Integer;
  dtm_Hatchet: Array[0..1] of Integer;
begin
  if (not LoggedIn) then
    Exit;
  
  dtm_Hatchet[DTM_HATCHET_NORMAL] :=
    DTMFromString('78DA639CC0C2C0709D910119E4050830F0036' +
       '990E87F2060EC07AAB98FAA868181094CC244197B816AEE105003' +
       'B2EB22013553806A2EE3570300C2B90C0B');

  dtm_Hatchet[DTM_HATCHET_DRAGON] :=
    DTMFromString('78DA63CC66666058C7C8800CFC05B819A6016' +
       '99828630A50CD6A54350C0C4C1039989A02A09A5504D41401D5AC' +
       '21A0260DA8661301352540355BF0AB0100FB0307CF');

  if (Players[CurrentPlayer].Booleans[P_EQUIPPED]) then
    GameTab(tab_Equip)
  else
    GameTab(tab_Inv);

  h := High(dtm_Hatchet);
  for i := 0 to h do
  begin
    Result := FindDTM(dtm_Hatchet[i], x, y, MIX1, MIY1, MIX2, MIY2);
    if Result then
      Break;
  end;
  
  FreeDTM(dtm_Hatchet[DTM_HATCHET_NORMAL]);
  FreeDTM(dtm_Hatchet[DTM_HATCHET_DRAGON]);
end;

{******************************************************************************}
{ function AutoColorFunction: Integer;                                         }
{ By: Nava2, edited by Coh3n                                                   }
{ Description: Finds best color on the minimap, depending on the RGB ranges    }
{******************************************************************************}
function Find_MMColors(Which: Integer): Integer;
var
  R, G, B, minR, maxR, minG, maxG, minB, maxB: Integer;
  i, h, c, curMax, j: Integer;
  t: TPointArray;
  CycleCols, newCols, colorCounts: TIntegerArray;
begin
  Result := -1;
  
  case Which of
    MM_ROAD:
      begin
        minR := 73; maxR := 100;
        minG := 75; maxG := 100;
        minB := 72; maxB := 97;
      end;
      
    MM_BANK:
      begin
        minR := 49; maxR := 63;
        minG := 51; maxG := 64;
        minB := 47; maxB := 60;
      end;
      
    MM_DUNGEON:
      begin
        minR := 240; maxR := 252;
        minG := 42;  maxG := 160;
        minB := 42;  maxB := 160;
      end;
      
    else
      Debug('Find_MMColors', 'Invalid Color parameters', DEBUG_ERROR);
  end;
  
  //Get all the colours in the minimap
  CycleCols := GetColors(ReturnMMTPA);
  ClearSameIntegers(CycleCols);

  //Cycle through creating a new array based on the inputted RGB max/mins
  h := High(CycleCols);
  setLength(newCols, h + 1);
  for i := 0 to h do
  begin
    ColorToRGB(CycleCols[i], R, G, B);
    if (InRange(R, minR, maxR) and InRange(G, minG, maxG)
        and InRange(B, minB, maxB)) then
    begin
      newCols[c] := CycleCols[i];
      Inc(c);
    end;
  end;

  setLength(newCols, c);
  setLength(colorCounts, c);
  Dec(c);

  {
    Use the colour which is most common. Could be substituted to use other
    means to pick the right colour post-RGB checks. (Density, TPA spread, etc.)
  }
  for i := 0 to c do
  begin
    FindColors(t, newCols[i], MMX1, MMY1, MMX2, MMY2);
    h := Length(t);
    if (h > curMax) then
    begin
      j := i;
      curMax := h;
    end;
  end;

  if (Length(newCols) > 0) then
  begin
    Result := newCols[j];
    Debug('Find_MMColors', 'Found Color: ' + IntToStr(Result), DEBUG_SUCCESS);
  end else
    Debug('Find_MMColors', 'Failed to find color: ' + IntToStr(Which), DEBUG_DETAILS);
end;

function Walk_ConstToLoc(which: Integer): String;
begin
  case which of
    WALK_TREES_WILLOWS, WALK_WILLOWS_RELOCATE:
      Result := 'Willows';

    WALK_TREES_OAKS_1:
      Result := 'Oaks[1]';

    WALK_TREES_OAKS_2:
      Result := 'Oaks';

    WALK_BANK_WILLOWS, WALK_BANK_OAKS_2, WALK_BANK_RELOCATE:
      Result := 'Bank';

    WALK_BANK_OAKS_1:
      Result := 'Bank[1]';

    else
      Debug('Walk_ConstToLoc', 'Invalid location', DEBUG_ERROR);
  end;
end;

function Walk_WaitWhile(where: Integer): Boolean;
var
  t: Integer;
begin
  t := GetSystemTime + 20000;
  while (GetSystemTime < t) do
  begin
    Randoms(1500, 3000);

    if (FFlag(5) or (not IsMoving) or (not FlagPresent)) then
    begin
      Players[CurrentPlayer].Loc := Walk_ConstToLoc(where);
      Debug('Walk_WaitWhile', 'Location - ' + Players[CurrentPlayer].Loc, DEBUG_PLAYER);
      Wait(RandomRange(500, 1000));
      Result := True;
      Break;
    end;
  end;
end;

function Walk_PerformIndex(which: Integer): Boolean;
var
  dungeonColor, bankColor, x, y: Integer;
begin
  if (not LoggedIn) then
    Exit;

  MakeCompass('n');
  RunEnergy(20);

  case which of
    WALK_TREES_WILLOWS:
      MouseBox(595, 113, 613, 130, CLICK_LEFT);

    WALK_TREES_OAKS_1:
      begin
        roadColor := Find_MMColors(MM_ROAD);
        if (not RadialWalkTolerance(roadColor, 85, 105, 60, 2, 1, 10)) then
          MouseBox(672, 85, 983, 97, CLICK_LEFT);
      end;

    WALK_TREES_OAKS_2:
      if (FindSymbolIn(x, y, 'dungeon', MMCX, MMY1, MMX2, MMY2)) then
        Mouse(x - Random(3), y - 15, 3, 3, True)
      else begin
        dungeonColor := Find_MMColors(MM_DUNGEON);
        if (not RadialWalkTolerance(dungeonColor, 65, 95, 60, -2, 15, 10)) then
          MouseBox(669, 55, 678, 63, CLICK_LEFT);
      end;

    WALK_BANK_WILLOWS:
      begin
        bankColor := Find_MMColors(MM_BANK);
        if (not RadialWalkTolerance(bankColor, 20, 50, 70, -5, 1, 10)) then
          MouseBox(645, 44, 656, 53, CLICK_LEFT);
      end;

    WALK_BANK_OAKS_1:
      begin
        roadColor := Find_MMColors(MM_ROAD);
        if (not RadialWalkTolerance(roadColor, 275, 240, 70, 2, 1, 10)) then
          MouseBox(569, 87, 578, 96, CLICK_LEFT);
      end;

    WALK_BANK_OAKS_2:
      begin
        bankColor := Find_MMColors(MM_BANK);
        if (not RadialWalkTolerance(bankColor, 295, 240, 70, 2, 1, 10)) then
          if (FindSymbolIn(x, y, 'bank', MMX1, MMY1, MMCX, MMY2)) then
            Mouse(x, y, 3, 3, True)
          else
            MouseBox(566, 101, 582, 112, CLICK_LEFT);
      end;
      
    WALK_BANK_RELOCATE:
      if (FindSymbolIn(x, y, 'bank', MMX1, MMY1, MMCX, MMY2)) then
        Mouse(x, y, 3, 3, True);
        
    WALK_WILLOWS_RELOCATE:
      if (FindSymbolIn(x, y, 'fishing', MMX1, MMY1, MMCX, MMY2)) then
        Mouse(x, y - 20, 3, 3, True);

    else
      Debug('Walk_PerformIndex', 'Invalid walk point', DEBUG_ERROR);
  end;

  Result := Walk_WaitWhile(which);
  if (Result) then
    Debug('Walk_PerformIndex', 'Walked to location: ' + Walk_ConstToLoc(which), DEBUG_SUCCESS)
  else
    Next_Player(False, 'Walk_PerformIndex', 'Failed to walk to location: ' + Walk_ConstToLoc(which));
end;

function Walk_ToLoc(where: Integer): Boolean;
begin
  case where of
    PATH_BANK_TO_WILLOWS:
      if (Players[CurrentPlayer].Loc = 'Bank') then
        Result := Walk_PerformIndex(WALK_TREES_WILLOWS)
      else
        Result := Players[CurrentPlayer].Loc = 'Willows';

    PATH_WILLOWS_TO_BANK:
      if (Players[CurrentPlayer].Loc = 'Willows') then
        Result := Walk_PerformIndex(WALK_BANK_WILLOWS)
      else
        Result := Players[CurrentPlayer].Loc = 'Bank';

    PATH_BANK_TO_OAKS:
      case Players[CurrentPlayer].Loc of
        'Bank':
          if (Walk_PerformIndex(WALK_TREES_OAKS_1)) then
            Result := Walk_PerformIndex(WALK_TREES_OAKS_2);
            
        'Oaks[1]':
          Result := Walk_PerformIndex(WALK_TREES_OAKS_2);
          
        'Oaks':
          Result := True;
          
        else
          Debug('Walk_ToLoc', 'Invalid location for PATH_BANK_TO_OAKS', DEBUG_ERROR);
      end;

    PATH_OAKS_TO_BANK:
      case Players[CurrentPlayer].Loc of
        'Oaks':
          if (Walk_PerformIndex(WALK_BANK_OAKS_1)) then
            Result := Walk_PerformIndex(WALK_BANK_OAKS_2);
            
        'Bank[1]':
          Result := Walk_PerformIndex(WALK_BANK_OAKS_2);
          
        'Bank':
          Result := True;

        else
          Debug('Walk_ToLoc', 'Invalid location for PATH_OAKS_TO_BANK', DEBUG_ERROR);
      end;

    else
      Debug('Walk_ToLoc', 'Invalid walk path', DEBUG_ERROR);
  end;

  if (Result) then
    Debug('Walk_ToLoc', 'Walked to ' + Walk_ConstToLoc(where), DEBUG_SUCCESS);
end;

function Chop_IsTreeDown: Boolean;
var
  inBox: TPointArray;
  tree: TMSObject;
begin
  if not LoggedIn or InvFull then Exit;
  tree := Load_MSObject(OBJ_TREE);

  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(tree.hueMod, tree.satMod);

  FindColorsTolerance(inBox, tree.Color, tP.x - 15, tP.y - 15, tP.x + 15, tP.y + 15, tree.tol);
  Result := (Length(inBox) < 20);
  Debug('Chop_IsTreeDown', 'Length inside Box: ' + IntToStr(Length(inBox)), DEBUG_DETAILS);

  if (Result) then
    Debug('Chop_IsTreeDown', 'Tree has been cut down!', DEBUG_DETAILS);

  SetColorSpeed2Modifiers(0.2, 0.2);
  ColorToleranceSpeed(1);
  FreeDTM(tree.dtm);
end;

function Chop_Trees: Boolean;
var
  tries, t, x, y: Integer;
begin
  if (not LoggedIn) then
    Exit;

  Result := InvFull;
  repeat
    if (Find_HoverObj(x, y, OBJ_TREE)) then
    begin
      Mouse(x, y, 0, 0, True);

      tP := IntToPoint(x, y);
      Debug('Chop_Trees', 'Track Point: (' + IntToStr(x) + ', ' + IntToStr(y) + ')', DEBUG_DETAILS);

      t := GetSystemTime + RandomRange(15000, 20000);
      while ((not Chop_IsTreeDown) and (GetSystemTime < t) and (not Result)) do
      begin
        Antiban;
        Randoms(500, 1000);
      end;
    end else begin
      Debug('Chop_Trees', 'Failed to find trees', DEBUG_ERROR);
      Wait(RandomRange(500, 1000));
      Inc(tries);
    end;

    if (tries >= 15) then
      Walk_PerformIndex(WALK_WILLOWS_RELOCATE);

  until(Result or (not LoggedIn));
end;

function Bank_Open: Boolean;
var
  x, y: Integer;
begin
  if (not LoggedIn) then
    Exit;

  if (Find_HoverObj(x, y, OBJ_BANK_BOOTH)) then
  begin
    Mouse(x, y, 0, 0, False);
    WaitOptionEx('uick', 'Action',  ClickLeft, 500);

    if (PinScreen) then
      InPin(Players[CurrentPlayer].Pin);

    Result := WaitFunc(@BankScreen, 50, 3000);
  end;
end;

function Bank_Logs: Boolean;
var
  logsInInv, tries, t: Integer;
  tree: TMSObject;
begin
  if (not LoggedIn) or (InvCount <= 1) then
    Exit;
  tree := Load_MSObject(OBJ_TREE);

  repeat
    if (Bank_Open) then
    begin
      Debug('Bank_Logs', 'Successfully opened bank!', DEBUG_SUCCESS);
      Wait(RandomRange(500, 1000));
      tries := 0;

      //count the logs in inventory
      logsInInv := CountItems('dtm', tree.dtm, []);
      IncEx(totalLogs, logsInInv);
      Disguise('Logs Chopped: ' + IntToStr(totalLogs));
      
      if (logsInInv > 0) then
        Debug('Bank_Logs', 'Found ' + IntToStr(logsInInv) + ' logs in inventory', DEBUG_DETAILS)
      else
        Debug('Bank_Logs', 'Failed to find dtm: ' + tree.name, DEBUG_ERROR);

      //deposit the logs
      if (Players[CurrentPlayer].Booleans[P_EQUIPPED]) then
        MouseBox(386, 300, 409, 315, CLICK_LEFT)
      else
        Deposit(2, 28, True);

      //waits for the logs to leave the inv (in case of lag)
      t := GetSystemTime + 5000;
      while (GetSystemTime < t) do
      begin
        Wait(RandomRange(200, 500));
        if (InvCount <= 1) then
        begin
          Result := True;
          Break;
        end;
      end;

    end else begin
      Debug('Bank_Logs', 'Failed to open bank', DEBUG_ERROR);
      Inc(tries);
    end;
    
    if (tries >= 15) then
      Walk_PerformIndex(WALK_BANK_RELOCATE);
      
  until ((tries >= 20) or Result);

  if (Result) then
  begin
    Debug('Bank_Logs', 'Successfully banked logs!', DEBUG_SUCCESS);
    Wait(RandomRange(250, 750));
    Inc(playerLoads);

    //randomly closes the bank, or just walks to the trees
    if (Random(10) > 4) then
      CloseBank;

    //add the necessary info to the progress report
    IncEx(Players[CurrentPlayer].Integers[P_EXP], Round(logsInInv * tree.exp));
    IncEx(Players[CurrentPlayer].Integers[P_LOGS], logsInInv);
    Inc(Players[CurrentPlayer].Integers[P_LOADS]);

    //send the necessary info to the stats server
    if (tree.name = 'Willow') then
      IncEx(Stats_CustomVars[STATS_WILLOWS], logsInInv)
    else
      IncEx(Stats_CustomVars[STATS_OAKS], logsInInv);
    IncEx(Stats_CustomVars[STATS_EXP], Round(logsInInv * tree.exp));
    Inc(Stats_CustomVars[STATS_LOADS]);
    Stats_Send;

    //checks to see if player has done specified number of logs
    with Players[CurrentPlayer] do
      if (Integers[P_LOGS] >= Integers[P_TOTAL_LOGS]) then
        Next_Player(False, 'Bank_Logs', 'Cut desired number of logs');
  end;

  FreeDTM(tree.dtm);
end;

function Report_GetTotals: TStringArray;
var
  i: Integer;
  temp: TIntegerArray;
begin
  SetLength(temp, 5);
  SetLength(Result, Length(temp));
  
  for i := 0 to High(Players) do
    with Players[i] do
    begin
      IncEx(temp[0], Integers[P_LOADS]);
      IncEx(temp[1], Integers[P_LOGS]);
      IncEx(temp[2], Integers[P_LEVELS]);
      IncEx(temp[3], Integers[P_EXP]);
      IncEx(temp[4], Integers[P_BREAKS]);
    end;
    
  for i := 0 to High(temp) do
    Result[i] := GroupDigits(temp[i], ',');
end;

procedure Report_ProgramInfo(right: Integer);
var
  theRunTime, theProgram, useSMART: String;
begin
  theRunTime := 'Ran For: ' + TimeRunning;
  
  {$IFDEF SIMBA}
    theProgram := 'Simba';
  {$ELSE}
    theProgram := 'SCAR';
  {$ENDIF}
  
  {$IFDEF SRL_SMART}
    useSMART := 'Yes';
  {$ELSE}
    useSMART := 'No';
  {$ENDIF}
  
  if (HowManyPlayers = 1) then
  begin
    AddToProggy(PadR('|    Program: ' + theProgram, right) + '|');
    AddToProggy(PadR('|    SMART:   ' + useSMART, right) + '|');
    AddToProggy(PadR('|    ' + theRunTime, right) + '|');
  end else
  begin
    AddToProggy(PadR('|                    ' + theRunTime, right) + '|');
    AddToProggy(PadR('|                             Program: ' + theProgram +
                      ' | SMART: ' + useSMART, right) + '|');
  end;
end;

procedure Report_MultiPlayer;
var
  i: Integer;
  s: TStringArray;
begin
  s := Report_GetTotals;
  AddToProggy('/=====================================================================================|'); //86
  AddToProggy(PadR('|                         Coh3n''s Draynor Chop N'' Bank!', 86) + '|');
  AddToProggy(PadR('|                                - Revision ' + SCRIPT_VERSION + ' -', 86) + '|');
  AddToProggy('|=====================================================================================|');
  AddToProggy('|                                                                                     |');
  Report_ProgramInfo(86);
  AddToProggy('|______ ________ __________ _______ ________ __________ ________ ____________ ________|');
  AddToProggy('| Nick | Active | Location | Loads |  Tree  | Logs Cut | Levels | Experience | Breaks |');
  AddToProggy('|¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯|');

  //adds all the player info to the report
  for i := 0 to High(Players) do
    with Players[i] do
      AddToProggy('| ' + PadR(Nick, 5) + '| ' + PadR(BoolToStr(Active), 7) + '| '
                        + PadR(Loc, 9) + '|  ' + PadR(GroupDigits(Integers[P_LOADS], ','), 5) + '| '
                        + PadR(Capitalize(Strings[P_TREE]), 7) + '|  ' + PadR(GroupDigits(Integers[P_LOGS], ','), 8) + '|   '
                        + PadR(IntToStr(Integers[P_LEVELS]), 5) + '|  ' + PadR(GroupDigits(Integers[P_EXP], ','), 10) + '|   '
                        + PadR(IntToStr(Integers[P_BREAKS]), 5) + '|');

  AddToProggy('|-------------------------------------------------------------------------------------|');
  AddToProggy(PadR('| Totals:', 27) + '|  ' + PadR(s[0], 5) + '|        |  ' + PadR(s[1], 8) + '|   '
                    + PadR(s[2], 5) + '|  ' + PadR(s[3], 10) + '|   ' + PadR(s[4], 5) + '|');
                    
  AddToProggy('|                                                                                     |');
  AddToProggy('| False Reasons:                                                                      |');
  
  //adds the false reasons to the report
  for i := 0 to High(Players) do
    if (not Players[i].Active) then
      AddToProggy(PadR('|   ' + Players[i].Nick + ': ' + falseReason[i], 86) + '|');
      
  AddToProggy('|_____________________________________________________________________________________|');
  AddToProggy('|_____________________________________________________________________________________/');
end;
  
procedure Report_SinglePlayer;
begin
  AddToProggy('/====================================================|');
  AddToProggy(PadR('|           Coh3n''s Draynor Chop N'' Bank!', 53) + '|');
  AddToProggy('|                  - Revision ' + SCRIPT_VERSION + ' -                   |');
  AddToProggy('|====================================================|');
  AddToProggy('|                                                    |');
  Report_ProgramInfo(53);
  AddToProggy('|                                                    |');
  
  with Players[CurrentPlayer] do
  begin
    AddToProggy(PadR('|    Player:   ' + Capitalize(Name), 53) + '|');
    AddToProggy(PadR('|    Active:   ' + BoolToStr(Active), 53) + '|');
    AddToProggy(PadR('|    Location: ' + Capitalize(Loc), 53) + '|');
    if (not Active) then
      AddToProggy(PadR('|    Reason:   ' + falseReason[CurrentPlayer], 53) + '|');
      
    AddToProggy(PadR('|      Tree Type:  ' + Capitalize(Strings[P_TREE]), 53) + '|');
    AddToProggy(PadR('|      Loads Done: ' + GroupDigits(Integers[P_LOADS], ','), 53) + '|');
    AddToProggy(PadR('|      Logs Cut:   ' + GroupDigits(Integers[P_LOGS], ','), 53) + '|');
    AddToProggy(PadR('|      Levels Up:  ' + IntToStr(Integers[P_LEVELS]), 53) + '|');
    AddToProggy(PadR('|      Experience: ' + GroupDigits(Integers[P_EXP], ','), 53) + '|');
    AddToProggy(PadR('|      Breaks:     ' + IntToStr(Integers[P_BREAKS]), 53) + '|');
  end;

  AddToProggy('|____________________________________________________|');
  AddToProggy('|____________________________________________________/');
end;

procedure Report_Print;
var
  i: Integer;
begin
  if (HowManyPlayers = 1) then
    Report_SinglePlayer
  else
    Report_MultiPlayer;
    
  for i := P_LOADS to P_BREAKS do
    if (Players[CurrentPlayer].Integers[i] > 0) then
      Players[CurrentPlayer].Integers[i] := Players[CurrentPlayer].Integers[i]
    else
      Players[CurrentPlayer].Integers[i] := 0;
end;

procedure Setup_Player;
begin
  LoginPlayer;
  Inc(Stats_CustomVars[STATS_LOGINS]);
  Stats_Send;
  
  hasLoggedIn[CurrentPlayer] := True;
  SetAngle(True);
  Randoms(250, 500);
  
  if (Find_Hatchet) then
    Debug('Setup_Player', 'Found hatchet!', DEBUG_SUCCESS)
  else
    Next_Player(False, 'Find_Hatchet', 'Failed to find hatchet');
end;

procedure Setup_Script;
var
  i: Integer;
begin
  {$IFDEF SIMBA}
    ClearDebug;
    Writeln('Thank you for using Draynor Chop N'' Bank - Simba version!');
  {$ELSE}
    Signature;
  {$ENDIF}
  
  if (USE_FORM) then
  begin
    tabCount := 1;
    SetLength(formPlayers, tabCount);

    frm_ShowPlayerForm;
    frm_KillForm;
    
    Stats_UserID := statsID;
    Stats_Password := statsPass;

    if (not startReady) then
      TerminateScript;
  end else
  
  begin
    Smart_Server := SMART_WORLD;
    Smart_Members := SMART_MEMBERS_WORLD;
    Smart_Signed := True;
    Smart_SuperDetail := False;
    
    Stats_UserID := STATS_ID;
    Stats_Password := STATS_PASS;
    playSnd := RANDOM_SOUND;
    breakAfter := BREAK_AFTER;
  end;
  
  Stats_ScriptID := '24';
  SetupSRL;
  ActivateClient;
  
  if (not USE_FORM) then
    DeclarePlayers;
  Disguise('Logs Chopped: 0');
  Writeln('Loading, please wait...');
  SymbolAccuracy := 0.5;
  
  SetLength(falseReason, HowManyPlayers);
  SetLength(hasLoggedIn, HowManyPlayers);
  
  for i := 0 to High(Players) do
  with Players[i] do
  begin
    falseReason[i] := '';
    BoxRewards := ['amp', 'mote', 'ostume', 'oins', 'unes', 're', 'ems'];
    Loc := 'Bank';
  end;
end;

procedure Setup_MainLoop;
begin
  Setup_Script;
  
  with Players[CurrentPlayer] do
    repeat
      if (not hasLoggedIn[CurrentPlayer]) then
        Setup_Player;
    
      if (Lowercase(Strings[P_TREE]) = 'willow') then
        Walk_ToLoc(PATH_BANK_TO_WILLOWS)
      else
        Walk_ToLoc(PATH_BANK_TO_OAKS);
        
      if (Chop_Trees) then
        if (Lowercase(Strings[P_TREE]) = 'willow') then
          Walk_ToLoc(PATH_WILLOWS_TO_BANK)
        else
          Walk_ToLoc(PATH_OAKS_TO_BANK);

      if (Bank_Logs) then
      begin
        {$IFDEF SIMBA}
          Debug('Setup_MainLoop', 'Sorry, no randoms report for Simba :(', DEBUG_DETAILS);
        {$ELSE}
          SRLRandomsReport;
        {$ENDIF}
        Report_Print;
        
        if (Booleans[P_TAKE_BREAKS]) then
          if (playerLoads >= (breakAfter + RandomRange(-2, 2))) then
          begin
            Next_Break;
            playerLoads := 0;
          end;
      end;
      
      if (not LoggedIn) then
      begin
        Next_Player(True, 'Setup_MainLoop', 'Player is logged out, switching players...');
        Debug('Setup_MainLoop', 'Waiting a few minutes in case of connection loss...', DEBUG_DETAILS);
        Wait(RandomRange(3*60000, 5*60000));
      end;
    until(AllPlayersInactive);
end;

procedure ScriptTerminate;
begin
  Report_Print;
end;

begin
  Setup_MainLoop;
end.

{==============================================================================\
|                    Copyright ©09-10 Coh3n @ SRL-Forums                       |
|==============================================================================}