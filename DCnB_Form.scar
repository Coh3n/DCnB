{.include SRL/SRL.scar}
{.Include srl\srl\Misc\Debug.scar}

{ const Players.Integers Indexes;
  Description: Constants representing the DeclarePlayers integers. }
const
   // Integers.
   P_TOTAL_LOGS  = 0;

   // Booleans.
   P_TAKE_BREAKS = 0;
   P_EQUIPPED    = 1;

   // Strings.
   P_TREE       = 0;
   P_LAMP_SKILL = 1;

   // Progress report.
   P_LOADS  = 9;
   P_LOGS   = 10;
   P_LEVELS = 11;
   P_EXP    = 12;
   P_BREAKS = 13;

const
  TAB_TABS   = 0;
  TAB_COMBOS = 1;
  TAB_EDITS  = 2;
  TAB_LABEL  = 3;

  TAB_BOX_COUNT = 4;
    BOX_ACTIVE    = 0;
    BOX_TREE      = 1;
    BOX_HATCHET   = 2;
    BOX_BREAKS    = 3;

  BOX_COUNT = 4;
    BOX_SMRT_MEM  = 0;
    BOX_SMRT_DTL  = 1;
    BOX_SMRT_CLNT = 2;
    BOX_SND       = 3;

  TAB_EDIT_COUNT = 5;
    EDIT_NAME = 0;
    EDIT_PASS = 1;
    EDIT_NICK = 2;
    EDIT_PIN  = 3;
    EDIT_LOGS = 4;

  EDIT_COUNT = 4;
    EDIT_SMRT_WLD  = 0;
    EDIT_STAT_ID   = 1;
    EDIT_STAT_PASS = 2;
    EDIT_BRK_AFTER = 3;

  IMG_COUNT = 27;
    // Used in frmMain
    IMG_BGND          = 0;
    IMG_X_NORM        = 1;
    IMG_Q_NORM        = 2;
    IMG_STRT_NORM     = 3;
    IMG_CRDTS_NORM    = 4;
    IMG_REQUIRED      = 5;

    // Used in the Script Setup tab
    IMG_TAB_PLR_DRK   = 6;
    IMG_TAB_SCPT_NORM = 7;
    IMG_SCPT_HEAD     = 8;
    IMG_SCPT_OTHR     = 9;
    IMG_SMRT_USE      = 10;
    IMG_SMRT_LBL      = 11;
    IMG_STAT_LBL      = 12;
    IMG_OTHR_LBL      = 13;
    IMG_Q_SND         = 14;
    IMG_Q_BRK         = 15;

    // Used in the Player Setup tab
    IMG_TAB_BDER      = 16;
    IMG_TAB_ADD_NORM  = 17;
    IMG_TAB_DLT_NORM  = 18;
    IMG_TAB_LABELS    = 19;
    IMG_TAB_SAVE_NORM = 20;
    IMG_TAB_LOAD_NORM = 21;

    // Used in frmHelp
    IMG_FRM_HELP = 22;
    IMG_X_SML    = 23;

    // Used in frmIntro
    IMG_FRM_INTRO = 24;
    IMG_CLOSE     = 25;

    // Used in frmCredits
    IMG_FRM_CREDITS = 26;

  BITMAP_COUNT = 41;
    BGND          = 0;
    INTRO         = 1;
    X_NORM        = 2;
    X_GLOW        = 3;
    Q_NORM        = 4;
    Q_GLOW        = 5;
    STRT_NORM     = 6;
    STRT_GLOW     = 7;
    TAB_SCPT_NORM = 8;
    TAB_SCPT_DRK  = 9;
    TAB_PLR_NORM  = 10;
    TAB_PLR_DRK   = 11;
    TAB_BDER      = 12;
    TAB_ACTIVE    = 13;
    TAB_INACTIVE  = 14;
    TAB_ADD_NORM  = 15;
    TAB_ADD_GLOW  = 16;
    TAB_DLT_NORM  = 17;
    TAB_DLT_GLOW  = 18;
    TAB_SAVE_NORM = 19;
    TAB_SAVE_GLOW = 20;
    TAB_LOAD_NORM = 21;
    TAB_LOAD_GLOW = 22;
    TAB_LABELS    = 23;
    SCPT_HEAD     = 24;
    SCPT_OTHR     = 25;
    SMRT_USE      = 26;
    SMRT_LBL      = 27;
    STAT_LBL      = 28;
    OTHR_LBL      = 29;
    Q_GLOW_LBL    = 30;
    Q_NORM_LBL    = 31;
    FRM_HELP      = 32;
    FRM_CREDITS   = 33;
    X_SML_NORM    = 34;
    X_SML_GLOW    = 35;
    CLOSE_NORM    = 36;
    CLOSE_GLOW    = 37;
    CRDTS_NORM    = 38;
    CRDTS_GLOW    = 39;
    REQUIRED      = 40;

  MAX_TAB_COUNT = 6;
  MIN_TAB_COUNT = 1;

  RECORD_COUNT = 9;
    REC_NAME    = 0;
    REC_PASS    = 1;
    REC_NICK    = 2;
    REC_PIN     = 3;
    REC_ACTIVE  = 4;
    REC_TREE    = 5;
    REC_LOGS    = 6;
    REC_HATCHET = 7;
    REC_BREAKS  = 8;

type
  TPlayer = record
    Name, Pass, Nick, Pin, Active, Tree, Logs, Hatchet, Breaks: String;
  end;

var
  statsID, statsPass: String;
  playSnd: Boolean;
  breakAfter: Integer;

  tabCount, currPlayer: Integer;
  formPlayers: Array of TPlayer;
  frmMain, frmHelp, frmIntro, frmCredits: TForm;
  errorMessage: TLabel;
  startReady, didLoad: Boolean;
  useSmart: tCheckBox;

  isActiveImage: Array[0..IMG_COUNT - 1] of Boolean;
  isActiveTab: Array of Boolean;
  frmBitmaps: Array [0..BITMAP_COUNT - 1] of Integer;

  tImages: Array[0..IMG_COUNT - 1] of TImage;
  tCombos: Array[0..BOX_COUNT - 1] of TComboBox;
  tEdits: Array[0..EDIT_COUNT - 1] of TEdit;

  tTabs: Array of TImage;
  tTabLabels: Array of TLabel;
  tTabCombos: Array[0..TAB_BOX_COUNT - 1] of TComboBox;
  tTabEdits: Array[0..TAB_EDIT_COUNT - 1] of TEdit;

procedure frm_Debug(Proc, s: String);
begin
  Writeln('-> [frm_Debug]: ' + Proc + ': ' + s);
end;

procedure frm_PlayerInfo(whichPlayer: Integer; saveInfo: Boolean);
begin
  if (saveInfo) then
    with formPlayers[currPlayer] do
    begin
      Name := tTabEdits[EDIT_NAME].Text;
      Pass := tTabEdits[EDIT_PASS].Text;
      Nick := tTabEdits[EDIT_NICK].Text;
      Pin  := tTabEdits[EDIT_PIN].Text;
      Active := tTabCombos[BOX_ACTIVE].Text;
      Tree := tTabCombos[BOX_TREE].Text;
      Logs := tTabEdits[EDIT_LOGS].Text;
      Hatchet := tTabCombos[BOX_HATCHET].Text;
      Breaks := tTabCombos[BOX_BREAKS].Text;
    end;

  currPlayer := whichPlayer;
  with formPlayers[currPlayer] do
  begin
    tTabEdits[EDIT_NAME].Text := Name;
    tTabEdits[EDIT_PASS].Text := Pass;
    tTabEdits[EDIT_NICK].Text := Nick;
    tTabEdits[EDIT_PIN].Text := Pin;
    tTabCombos[BOX_ACTIVE].Text := Active;
    tTabCombos[BOX_TREE].Text := Tree;
    tTabEdits[EDIT_LOGS].Text := Logs;
    tTabCombos[BOX_HATCHET].Text := Hatchet;
    tTabCombos[BOX_BREAKS].Text := Breaks;
  end;
end;

procedure tab_ManageLabels(i: Integer);
begin
  if (formPlayers[i].Name = '') then
    tTabLabels[i].Caption := 'Player ' + IntToStr(i + 1)
  else
    if (Length(formPlayers[i].Name) <= 7) then
      tTabLabels[i].Caption := formPlayers[i].Name
    else
      tTabLabels[i].Caption := Copy(formPlayers[i].Name, 1, 6) + '...';
end;

procedure tab_CreateObject(theSender: Integer; useHigh: Boolean);
var
  bmp, w, h, i: Integer;
begin
  if (not useHigh) then
    i := 0;

  case theSender of
    TAB_TABS:
      begin
        SetLength(tTabs, tabCount);
        SetLength(isActiveTab, tabCount);
        if (useHigh) then
          i := High(tTabs);

        tTabs[i] := TImage.Create(frmMain);
        with tTabs[i] do
        begin
          Parent := frmMain;
          bmp := frmBitmaps[TAB_ACTIVE];
          GetBitmapSize(bmp, w, h);
          SetBounds({L} 50 + (i * 74), {T} 161, {W} w, {H} h);
          {$ifdef Simba}
          DrawBitmap(Bmp,canvas,0,0);
          {$else}
          SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas, 0, 0, w, h, 0, 0, w, h);
          {$endif}
          isActiveTab[i] := True;

          if (isActiveImage[IMG_TAB_SCPT_NORM]) then
            Visible := False
          else
            Visible := True;
        end;
      end;

    TAB_LABEL:
      begin
        SetLength(tTabLabels, tabCount);
        if (useHigh) then
          i := High(tTabLabels);

        tTabLabels[i] := TLabel.Create(frmMain);
        with tTabLabels[i] do
        begin
          Parent := frmMain;
          SetBounds({L} 62 + (i * 74), {T} 163, {W} w, {H} h);
          Font.Name := 'Verdana';
          Font.Size := 8;
          Font.Color := 2070783;
          Caption := 'Player ' + IntToStr(i + 1);

          if (isActiveImage[IMG_TAB_SCPT_NORM]) then
            Visible := False
          else
            Visible := True;
        end;
      end;

    else begin
      frm_Debug('tab_CreateObject', 'Invalid theSender parameter!');
      Exit;
    end;
  end;
end;

function tab_GetActive: Integer;
var
  hi, i: Integer;
begin
  Result := -1;
  if (Length(tTabs) <= 0) then
    Exit;

  hi := High(tTabs);
  for i := 0 to hi do
    if (isActiveTab[i]) then
    begin
      Result := i;
      Exit;
    end;
end;

procedure tab_OnHover(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i, w, h: Integer;
  intArr: TIntegerArray;
begin
  for i := IMG_TAB_ADD_NORM to IMG_TAB_DLT_NORM do
  begin
    if (i = IMG_TAB_ADD_NORM) then
      intArr := [IMG_TAB_ADD_NORM, frmBitmaps[TAB_ADD_NORM]]
    else
      intArr := [IMG_TAB_DLT_NORM, frmBitmaps[TAB_DLT_NORM]];

    if (tImages[i].Visible) then
    begin
      if (not isActiveImage[intArr[0]]) then
        Exit;
      GetBitmapSize(intArr[1], w, h);
      {$ifdef Simba}
      DrawBitmap(intarr[1],tImages[intArr[0]].Canvas,0,0);
      {$else}
      SafeCopyCanvas(GetBitmapCanvas(intArr[1]), tImages[intArr[0]].Canvas,
                     0, 0, w, h, 0, 0, w, h);
      {$endif}
      isActiveImage[intArr[0]] := False;
    end;
  end;
end;

const
  ACTIVE   = 0;
  INACTIVE = 1;
procedure tab_Activate(Sender: TObject);
var
  intArr: TIntegerArray;
  theSender, currTab, bmp, i, w, h: Integer;
begin
  currTab := tab_GetActive;
  theSender := -1;
  if ((Length(tTabs) = 1) or (Sender = tTabs[currTab])) then
    Exit;

  for i := 0 to tabCount - 1 do
    if (Sender = tTabLabels[i]) or (Sender = tTabs[i]) then
    begin
      //Writeln('Sender: ' + IntToStr(i));
      theSender := i;
      Break;
    end;

  if (theSender = -1) then
  begin
    frm_Debug('tab_Activate', 'Invalid Sender: theSender = -1');
    Exit;
  end;

  intArr := [frmBitmaps[TAB_ACTIVE], frmBitmaps[TAB_INACTIVE]];
  {
    Replaces the active tab with the inactive tab bitmap, and sets that tab
    inactive.
  }
  if (currTab > -1) then
  begin
    bmp := intArr[INACTIVE];
    GetBitmapSize(bmp, w, h);
    {$ifdef Simba}
    DrawBitmap(bmp,tTabs[currTab].Canvas,0,0);
    {$else}
    SafeCopyCanvas(GetBitmapCanvas(bmp), tTabs[currTab].Canvas,
                   0, 0, w, h, 0, 0, w, h);
    {$endif}
    tTabLabels[currTab].Font.Color := 1068418;
    isActiveTab[currTab] := False;
    frm_PlayerInfo(currTab, True);
    tab_ManageLabels(currTab);
    //frm_Debug('tab_Activate', 'Tab ' + IntToStr(currTab + 1) + ' is now inactive.');
  end;
  {
    Replaces the inactive tab clicked with the active tab bitmap, and sets that
    tab to active.
  }
  bmp := intArr[ACTIVE];
  GetBitmapSize(bmp, w, h);
  {$ifdef Simba}
  DrawBitmap(bmp,tTabs[theSender].Canvas,0,0);
  {$else}
  SafeCopyCanvas(GetBitmapCanvas(bmp), tTabs[theSender].Canvas, 0, 0, w, h, 0, 0, w, h);
  {$endif}
  tTabLabels[theSender].Font.Color := 2070783;
  isActiveTab[theSender] := True;
  frm_PlayerInfo(theSender, True);
  tab_ManageLabels(theSender);

  //frm_Debug('tab_Activate', 'Tab ' + IntToStr(theSender + 1) + ' is now active.');
end;

const
  FROM_LEFT = 0;
  IF_LEFT   = 1;
  ELSE_LEFT = 2;
procedure tab_ShiftButtons(Add: Boolean);
var
  shRight: Integer;
  intArr: TIntegerArray;
begin
  if (Add) then
    intArr := [127, 82, 74]
  else
    intArr := [209, -82, -74];
  {
    Shifts the add tab and delete tab buttons according to current position
    from the left of the main form.
  }
  with tImages[IMG_TAB_ADD_NORM] do
  begin
    if (Left = intArr[FROM_LEFT]) then
      shRight := intArr[IF_LEFT]
    else
      shRight := intArr[ELSE_LEFT];

    Left := Left + shRight;
    {
      If 6 tabs exists, the add tab button won't be visible.
    }
    if (Left >= 127 + (74 * 5)) then
      Visible := False
    else
      Visible := True;
  end;

  with tImages[IMG_TAB_DLT_NORM] do
  begin
    Left := Left + intArr[ELSE_LEFT];
    {
      If one tabs exists, the delete tab button won't be visible.
    }
    if (Left > 127) then
      Visible := True
    else
      Visible := False;
  end;
end;

procedure tab_Add(loaded: Boolean);
var
  bmp, hi, w, h, i: Integer;
begin
  tab_ShiftButtons(True);

  if (tabCount > MAX_TAB_COUNT) then
  begin
    frm_Debug('tab_Add', 'Maximum tab number has been reached.');
    Exit;
  end;

  Inc(tabCount);

  if (not loaded) then
    SetLength(formPlayers, tabCount);
  {
    Creates the TImage for the index just added to the tTabs array.
  }
  tab_CreateObject(TAB_TABS, True);
  tab_CreateObject(TAB_LABEL, True);

  if (not loaded) then
    frm_PlayerInfo(High(formPlayers), True);
  {
    Finds all the tabs that are active, and replaces the active tab bitmap
    with the inactive bitmap. Also sets the active tabs to inactive.
  }
  hi := High(tTabs);
  if (Length(tTabs) > 1) then
    for i := 0 to (hi - 1) do
      with tTabs[i] do
      begin
        if (not isActiveTab[i]) then
          Continue;

        bmp := frmBitmaps[TAB_INACTIVE];
        GetBitmapSize(bmp, w, h);
        {$ifdef Simba}
        DrawBitmap(bmp,canvas,0,0);
        {$else}
        SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas,
                       0, 0, w, h, 0, 0, w, h);
        {$endif}
        isActiveTab[i] := False;
        //frm_Debug('tab_Add', 'Tab ' + IntToStr(i + 1) + ' is now inactive.');
      end;

  for i := 0 to hi do
  begin
    tTabs[i].OnClick := @tab_Activate;
    tTabs[i].OnMouseMove := @tab_OnHover;
  end;

  hi := High(tTabLabels);
  for i := 0 to hi do
  begin
    tTabLabels[i].OnClick := @tab_Activate;
    tTabLabels[i].OnMouseMove := @tab_OnHover;
  end;

  tab_ManageLabels(hi - 1);

  //frm_Debug('tab_Add', 'There are ' + IntToStr(Length(tTabs)) + ' tabs.');
end;

procedure tab_Delete;
var
  bmp, hi, w, h: Integer;
begin
  tab_ShiftButtons(False);

  if (tabCount < MIN_TAB_COUNT) then
  begin
    frm_Debug('tab_Delete', 'Minimum tab number has been reached.');
    Exit;
  end;

  hi := High(tTabs);
  if (Length(tTabs) > 1) then
    with tTabs[hi - 1] do
      if (isActiveTab[hi]) then
      begin
        frm_PlayerInfo(hi - 1, False);
        bmp := frmBitmaps[TAB_ACTIVE];
        GetBitmapSize(bmp, w, h);
        {$ifdef Simba}
        DrawBitmap(bmp,canvas,0,0);
        {$else}
        SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas, 0, 0, w, h, 0, 0, w, h);
        {$endif}
        tTabLabels[hi - 1].Font.Color := 2070783;
        isActiveTab[hi - 1] := True;
        //frm_Debug('tab_Delete', 'Tab ' + IntToStr(hi - 1) + ' is now active.');
      end;

  if (Length(tTabs) > 0) then
  begin
    tTabs[hi].Visible := False;
    isActiveTab[hi] := False;
    tTabs[hi].Free;

    tTabLabels[hi].Visible := False;
    tTabLabels[hi].Free;

    Dec(tabCount);
    SetLength(tTabs, tabCount);
    SetLength(isActiveTab, tabCount);
    SetLength(formPlayers, tabCount);
  end;

  //frm_Debug('tab_Delete', 'There are ' + IntToStr(Length(tTabs)) + ' tabs.');
end;

procedure frm_ShowMessage(s: String; l, t, w, h: Integer);
begin
  frmHelp.Visible := True;

  errorMessage := TLabel.Create(frmHelp);
  with errorMessage do
  begin
    Parent := frmHelp;
    SetBounds({L} l, {T} t, {W} w, {H} h);
    Font.Name := 'Verdana';
    Font.Color := clWhite;
    Font.Style := [fsBold];
    Font.Size := 9;
    Caption := s;
  end;
end;

procedure frm_SavePlayers(Sender: TObject);
var
  i: Integer;
begin
  DeleteINI('Player List', '', ScriptPath + 'DCnB_PlayerList');
  WriteINI('Player List', 'NumberOfPlayers',
           ' ' + IntToStr(Length(formPlayers)), ScriptPath + 'DCnB_PlayerList');

  for i := 0 to High(formPlayers) do
    with formPlayers[i] do
    begin
      if (i = High(formPlayers)) then
        if (Name = '') then
          begin
            Name := tTabEdits[EDIT_NAME].Text;
            Pass := tTabEdits[EDIT_PASS].Text;
            Nick := tTabEdits[EDIT_NICK].Text;
            Pin  := tTabEdits[EDIT_PIN].Text;
            Active := tTabCombos[BOX_ACTIVE].Text;
            Tree := tTabCombos[BOX_TREE].Text;
            Logs := tTabEdits[EDIT_LOGS].Text;
            Hatchet := tTabCombos[BOX_HATCHET].Text;
            Breaks := tTabCombos[BOX_BREAKS].Text;
          end;

      WriteINI('Player List', 'Name' + IntToStr(i), ' ' + Name, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Pass' + IntToStr(i), ' ' + Pass, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Nick' + IntToStr(i), ' ' + Nick, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Pin' + IntToStr(i), ' ' + Pin, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Active' + IntToStr(i), ' ' + Active, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Tree' + IntToStr(i), ' ' + Tree, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Logs' + IntToStr(i), ' ' + Logs, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Hatchet' + IntToStr(i), ' ' + Hatchet, ScriptPath + 'DCnB_PlayerList');
      WriteINI('Player List', 'Breaks' + IntToStr(i), ' ' + Breaks, ScriptPath + 'DCnB_PlayerList');
    end;

  WriteINI('Setup Info', 'Play Sound', tCombos[BOX_SND].Text, ScriptPath + 'DCnB_PlayerList');
  WriteINI('Setup Info', 'Break After', tEdits[EDIT_BRK_AFTER].Text, ScriptPath + 'DCnB_PlayerList');
  WriteINI('Setup Info', 'Stats ID', tEdits[EDIT_STAT_ID].Text, ScriptPath + 'DCnB_PlayerList');
  WriteINI('Setup Info', 'Stats PAss', tEdits[EDIT_STAT_PASS].Text, ScriptPath + 'DCnB_PlayerList');

  frm_ShowMessage('Successfully saved players! The ' + #10 +
                  'file can be found in your DCnB ' + #10 + 'folder.', 20, 35, 100, 20);
end;

procedure frm_LoadPlayers(Sender: TObject);
var
  records: Array of Array of String;
  i: Integer;
  s: String;
begin
  if (didLoad) then
  begin
    frm_ShowMessage('You''ve already loaded a player ' + #10 + 'list!', 22, 43, 100, 20);
    Exit;
  end;

  if (not FileExists(ScriptPath + 'DCnB_PlayerList')) then
  begin
    frm_ShowMessage('You need to save a player list ' + #10 + 'before you can load one!',
                    26, 43, 100, 20);
    Exit;
  end;

  didLoad := True;
  s := ReadINI('Player List', 'NumberOfPlayers', ScriptPath + 'DCnB_PlayerList');
  SetLength(formPlayers, StrToInt(s));

  SetLength(records, Length(formPlayers));
  for i := 0 to High(records) do
  begin
    SetLength(records[i], RECORD_COUNT);

    records[i][REC_NAME] := ReadINI('Player List', 'Name' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_PASS] := ReadINI('Player List', 'Pass' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_NICK] := ReadINI('Player List', 'Nick' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_PIN] := ReadINI('Player List', 'Pin' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_ACTIVE] := ReadINI('Player List', 'Active' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_TREE] := ReadINI('Player List', 'Tree' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_LOGS] := ReadINI('Player List', 'Logs' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_HATCHET] := ReadINI('Player List', 'Hatchet' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
    records[i][REC_BREAKS] := ReadINI('Player List', 'Breaks' + IntToStr(i), ScriptPath + 'DCnB_PlayerList');
  end;

  for i := 0 to High(formPlayers) do
  begin
    with formPlayers[i] do
    begin
      Name := records[i][REC_NAME];
      Pass := records[i][REC_PASS];
      Nick := records[i][REC_NICK];
      Pin := records[i][REC_PIN];
      Active := records[i][REC_ACTIVE];
      Tree := records[i][REC_TREE];
      Logs := records[i][REC_LOGS];
      Hatchet := records[i][REC_HATCHET];
      Breaks := records[i][REC_BREAKS];

      if (i = High(formPlayers)) then
      begin
        tTabEdits[EDIT_NAME].Text := Name;
        tTabEdits[EDIT_PASS].Text := Pass;
        tTabEdits[EDIT_NICK].Text := Nick;
        tTabEdits[EDIT_PIN].Text := Pin;
        tTabCombos[BOX_ACTIVE].Text := Active;
        tTabCombos[BOX_TREE].Text := Tree;
        tTabEdits[EDIT_LOGS].Text := Logs;
        tTabCombos[BOX_HATCHET].Text := Hatchet;
        tTabCombos[BOX_BREAKS].Text := Breaks;
        currPlayer := i;
      end;
    end;

    if (i > 0) then
      tab_Add(True);

    if (i = High(formPlayers)) then
      tTabLabels[i].Font.Color := 2070783
    else
      tTabLabels[i].Font.Color := 1068418;

    tab_ManageLabels(i);
  end;

  frm_ShowMessage('Successfully loaded players!', 35, 50, 100, 20);
end;

function frm_BoolToBool(s: String): Boolean;
var
  options: TStringArray;
begin
  options := ['Yes', 'Equipped', 'Members', 'High', 'Signed'];
  Result := InStrArr(s, options, False);
end;

procedure frm_StartScript;
var
  hi, i: Integer;
begin
  frm_PlayerInfo(currPlayer, True);
  SetLength(Players, Length(formPlayers));
  HowManyPlayers := Length(Players);
  NumberOfPlayers(HowManyPlayers);
  {
    Checks all the script-specific info, and gives a warning message when
    necessary.
  }
  hi := High(tCombos);
  for i := 0 to hi - 1 do
    if (tCombos[i].Text = '') then
      if (not useSMART.Checked) then
      begin
        frm_ShowMessage('Please fill out all S.M.A.R.T. ' + #10 + 'fields!', 38, 42, 100, 20);
        Exit;
      end;
  {
    Checks all the player-specific info, and gives a warning message when
    necessary.
  }
  hi := High(formPlayers);
  for i := 0 to hi do
    with formPlayers[i] do
    begin
      SetLength(Players[i].Integers, 14);
      SetLength(Players[i].Strings, 2);
      SetLength(Players[i].Booleans, 2);

      if (Name = '') or (Pass = '') or (Nick = '') or (Active = '') or
         (Tree = '') or (Logs = '') or (Hatchet = '') then
      begin
        frmHelp.Visible := True;
        frm_ShowMessage('Please fill out all required ' + #10 +
                        'fields for Player ' + IntToStr(i + 1) + '.', 42, 42, 100, 20);
        Exit;
      end;

      Players[i].Name := formPlayers[i].Name;
      Players[i].Pass := formPlayers[i].Pass;
      Players[i].Nick := formPlayers[i].Nick;
      Players[i].Pin := formPlayers[i].Pin;
      Players[i].Strings[P_TREE] := formPlayers[i].Tree;
      Players[i].Booleans[P_TAKE_BREAKS] := frm_BoolToBool(formPlayers[i].Breaks);

      Players[i].Active := frm_BoolToBool(formPlayers[i].Active);
      if (not Players[i].Active) then
        if (Lowercase(formPlayers[i].Active) <> 'no') then
        begin
          frmHelp.Visible := True;
          frm_ShowMessage('Invalid use player for Player' + IntToStr(i + 1) + '.', 29, 48, 100, 20);
          Exit;
        end;

      Players[i].Integers[P_TOTAL_LOGS] := StrToInt(formPlayers[i].Logs);
      if (Players[i].Integers[P_TOTAL_LOGS] = -1) then
      begin
        frmHelp.Visible := True;
        frm_ShowMessage('Invalid number of logs for ' + #10 +
                        'Player ' + IntToStr(i + 1) + '. Be sure to use numbers'
                        + #10 + 'only.', 19, 35, 100, 20);
        Exit;
      end;

      Players[i].Booleans[P_EQUIPPED] := frm_BoolToBool(formPlayers[i].Hatchet);
      if (not Players[i].Booleans[P_EQUIPPED]) then
        if (Lowercase(formPlayers[i].Hatchet) <> 'inventory') then
        begin
          frmHelp.Visible := True;
          frm_ShowMessage('Invalid hatchet status for ' + #10 +
                          'Player' + IntToStr(i + 1) + '.', 29, 42, 100, 20);
          Exit;
        end;
    end;

  startReady := True;

  if (startReady) then
  begin
    Smart_Server := StrToInt(tEdits[EDIT_SMRT_WLD].Text);
    Smart_Members := frm_BoolToBool(tCombos[BOX_SMRT_MEM].Text);
    Smart_Signed := frm_BoolToBool(tCombos[BOX_SMRT_CLNT].Text);
    Smart_SuperDetail := frm_BoolToBool(tCombos[BOX_SMRT_DTL].Text);

    statsID := tEdits[EDIT_STAT_ID].Text;
    statsPass := tEdits[EDIT_STAT_PASS].Text;
    playSnd := frm_BoolToBool(tCombos[BOX_SND].Text);
    breakAfter := StrToInt(tEdits[EDIT_BRK_AFTER].Text);
  end;
  frmMain.ModalResult := mrOk;
end;

procedure frm_OnClick(Sender: TObject);
var
  hi, w, h, i, k: Integer;
  bmpArr, imgArr: TIntegerArray;
begin
  case Sender of
    tImages[IMG_X_NORM]:
      frmMain.ModalResult := mrOk; // Closes the main form (frmMain).

    tImages[IMG_STRT_NORM]:
      frm_StartScript;

    tImages[IMG_TAB_PLR_DRK], tImages[IMG_TAB_SCPT_NORM]:
      begin
        if (Sender = tImages[IMG_TAB_PLR_DRK]) then
        begin
          bmpArr := [ frmBitmaps[TAB_SCPT_DRK], frmBitmaps[TAB_PLR_NORM] ];
          imgArr := [ IMG_TAB_SCPT_NORM, IMG_TAB_PLR_DRK ];

          isActiveImage[IMG_TAB_SCPT_NORM] := False;
          isActiveImage[IMG_TAB_PLR_DRK] := True;

          for i := IMG_SCPT_HEAD to IMG_Q_BRK do
            tImages[i].Visible := False;

          for i := BOX_SMRT_MEM to BOX_SND do
            tCombos[i].Visible := False;

          for i := EDIT_SMRT_WLD to EDIT_BRK_AFTER do
            tEdits[i].Visible := False;

          for i := IMG_TAB_BDER to IMG_TAB_LOAD_NORM do
            tImages[i].Visible := True;

          for i := BOX_ACTIVE to BOX_BREAKS do
            tTabCombos[i].Visible := True;

          for i := EDIT_NAME to EDIT_LOGS do
            tTabEdits[i].Visible := True;

          tImages[IMG_TAB_LABELS].Visible := True;
          useSmart.Visible := False;

          if (tImages[IMG_TAB_ADD_NORM].Left >= 127 + (74 * 5)) then
            tImages[IMG_TAB_ADD_NORM].Visible := False;

          if (tImages[IMG_TAB_DLT_NORM].Left > 127) then
            tImages[IMG_TAB_DLT_NORM].Visible := True
          else
            tImages[IMG_TAB_DLT_NORM].Visible := False;
        end else

        begin
          bmpArr := [ frmBitmaps[TAB_PLR_DRK], frmBitmaps[TAB_SCPT_NORM] ];
          imgArr := [ IMG_TAB_PLR_DRK, IMG_TAB_SCPT_NORM ];

          isActiveImage[IMG_TAB_SCPT_NORM] := True;
          isActiveImage[IMG_TAB_PLR_DRK] := False;

          for i := IMG_SCPT_HEAD to IMG_Q_BRK do
            tImages[i].Visible := True;

          for i := BOX_SMRT_MEM to BOX_SND do
            tCombos[i].Visible := True;

          for i := EDIT_SMRT_WLD to EDIT_BRK_AFTER do
            tEdits[i].Visible := True;

          for i := IMG_TAB_BDER to IMG_TAB_LOAD_NORM do
            tImages[i].Visible := False;

          for i := BOX_ACTIVE to BOX_BREAKS do
            tTabCombos[i].Visible := False;

          for i := EDIT_NAME to EDIT_LOGS do
            tTabEdits[i].Visible := False;

          tImages[IMG_TAB_LABELS].Visible := False;
          useSmart.Visible := True;
        end;

        hi := High(bmpArr);
        for i := 0 to hi do
        begin
          GetBitmapSize(bmpArr[i], w, h);
          {$ifdef Simba}
          DrawBitmap(bmpArr[i],tImages[imgArr[i]].Canvas,0,0);
          {$else}
          SafeCopyCanvas(GetBitmapCanvas(bmpArr[i]), tImages[imgArr[i]].Canvas,
                     0, 0, w, h, 0, 0, w, h);
          {$endif}
        end;

        hi := High(tTabs);
        for k := 0 to hi do
          if (isActiveImage[IMG_TAB_SCPT_NORM]) then
          begin
            tTabs[k].Visible := False;
            tTabLabels[k].Visible := False;
          end else
          begin
            tTabs[k].Visible := True;
            tTabLabels[k].Visible := True;
          end;
      end;

    tImages[IMG_Q_SND], tImages[IMG_Q_BRK]:
      begin
        frmHelp.Visible := True;

        if (Sender = tImages[IMG_Q_SND]) then
          frm_ShowMessage('Do you want the script to play' + #10 +
                          'a sound when a random event' + #10 + 'is found?', 28, 37, 100, 20)
        else
          frm_ShowMessage('How many loads do you want' + #10 +
                          'to bank before breaking/switching' + #10 +
                          'players? Leave blank if you ' + #10 +
                          'don''t want to take breaks.', 15, 30, 100, 20);
      end;

    tImages[IMG_X_SML]:
      begin
        frmHelp.Visible := False;
        errorMessage.Free;
      end;

    tImages[IMG_Q_NORM], tImages[IMG_CRDTS_NORM]:
      begin
        if (Sender = tImages[IMG_Q_NORM]) then
        begin
          tImages[IMG_CLOSE].Parent := frmIntro;
          frmIntro.Visible := True
        end else
        begin
          tImages[IMG_CLOSE].Parent := frmCredits;
          frmCredits.Visible := True;
        end;

        tImages[IMG_CLOSE].Visible := True;
      end;

    tImages[IMG_CLOSE]:
      begin
        if (frmIntro.Visible) then
          frmIntro.Visible := False;

        if (frmCredits.Visible) then
          frmCredits.Visible := False;

        tImages[IMG_CLOSE].Visible := False;
      end;

    tImages[IMG_TAB_ADD_NORM]:
      begin
        tab_Add(False);

        hi := High(tTabs);
        for i := 0 to hi do
          if (not isActiveTab[i]) then
            tTabLabels[i].Font.Color := 1068418;
      end;

    tImages[IMG_TAB_DLT_NORM]:
      tab_Delete;

    useSMART:
      if (useSmart.Checked) then
      begin
        for i := BOX_SMRT_MEM to BOX_SMRT_CLNT do
          tCombos[i].Enabled := False;

        tEdits[EDIT_SMRT_WLD].Enabled := False;
      end else
      begin
        for i := BOX_SMRT_MEM to BOX_SMRT_CLNT do
          tCombos[i].Enabled := True;

        tEdits[EDIT_SMRT_WLD].Enabled := True;
      end;

    else begin
      frm_Debug('frm_OnClick', 'Invalid Sender!');
      Exit;
    end;
  end;
end;

{******************************************************************************}
{ Name: Form_OnKeyPress                                                        }
{ By: SKy Scripter                                                             }
{ Description: Keeps stupid people from typing in the combobox                 }
{******************************************************************************}
procedure frm_OnKeyPress(Sender: TObject; var Key: Char);
begin
  Key := Chr(VK_CANCEL);
end;

procedure frm_OnMouseMove(Sender: TObject; Shift: TShiftState; x, y: Integer);
var
  bmp, hi, w, h, i: Integer;
  bmpArr, imgArr, intArr: TIntegerArray;
begin
  case Sender of
    tImages[IMG_BGND]:
      begin
        bmpArr := [ X_NORM, Q_NORM, BGND, STRT_NORM, Q_GLOW_LBL, Q_GLOW_LBL,
                    X_SML_NORM, CLOSE_NORM, CRDTS_NORM, TAB_ADD_NORM,
                    TAB_DLT_NORM, TAB_SAVE_NORM, TAB_LOAD_NORM, TAB_LABELS ];

        imgArr := [ IMG_X_NORM, IMG_Q_NORM, IMG_BGND, IMG_STRT_NORM, IMG_Q_SND,
                    IMG_Q_BRK, IMG_X_SML, IMG_CLOSE, IMG_CRDTS_NORM,
                    IMG_TAB_ADD_NORM, IMG_TAB_DLT_NORM, IMG_TAB_SAVE_NORM,
                    IMG_TAB_LOAD_NORM, IMG_TAB_LABELS ];

        hi := High(bmpArr);
        for i := 0 to hi do
        begin
          if (not isActiveImage[imgArr[i]]) then
            Continue;

          bmp := frmBitmaps[bmpArr[i]];
          GetBitmapSize(bmp, w, h);
          {$ifdef Simba}
          DrawBitmap(bmp,tImages[imgArr[i]].Canvas,0,0);
          {$else}
          SafeCopyCanvas(GetBitmapCanvas(bmp), tImages[imgArr[i]].Canvas,
                         0, 0, w, h, 0, 0, w, h);
          {$endif}
          isActiveImage[imgArr[i]] := False;
        end;

        hi := High(tImages);
        for i := 0 to hi do
          case i of
            IMG_BGND..IMG_TAB_SCPT_NORM:
              tImages[i].Visible := True;

            IMG_SCPT_HEAD..IMG_Q_BRK:
              if (isActiveImage[IMG_TAB_SCPT_NORM]) then
                tImages[i].Visible := True;
          end;

        hi := High(tCombos);
        for i := 0 to hi do
          case i of
            BOX_SMRT_MEM..BOX_SND:
              if (isActiveImage[IMG_TAB_SCPT_NORM]) then
                tCombos[i].Visible := True;
          end;

        hi := High(tEdits);
        for i := 0 to hi do
          case i of
            EDIT_SMRT_WLD..EDIT_BRK_AFTER:
              if (isActiveImage[IMG_TAB_SCPT_NORM]) then
                tEdits[i].Visible := True;
          end;
      end;

    tImages[IMG_FRM_HELP], tImages[IMG_FRM_INTRO], tImages[IMG_FRM_CREDITS]:
      begin
        if (Sender = tImages[IMG_FRM_HELP]) then
          intArr := [IMG_X_SML, frmBitmaps[X_SML_NORM]]
        else
          intArr := [IMG_CLOSE, frmBitmaps[CLOSE_NORM]];

        if (not isActiveImage[intArr[0]]) then
          Exit;
        GetBitmapSize(intArr[1], w, h);
        {$ifdef Simba}
        DrawBitmap(intArr[1],tImages[intArr[0]].Canvas,0,0);
        {$else}
        SafeCopyCanvas(GetBitmapCanvas(intArr[1]), tImages[intArr[0]].Canvas,
                       0, 0, w, h, 0, 0, w, h);
        {$endif}
        isActiveImage[intArr[0]] := False;
      end;

    tImages[IMG_X_NORM], tImages[IMG_Q_NORM], tImages[IMG_STRT_NORM],
    tImages[IMG_X_SML], tImages[IMG_Q_SND], tImages[IMG_Q_BRK],
    tImages[IMG_CLOSE], tImages[IMG_CRDTS_NORM], tImages[IMG_TAB_ADD_NORM],
    tImages[IMG_TAB_DLT_NORM]:
      begin
        case Sender of
          tImages[IMG_X_NORM]:
            intArr := [IMG_X_NORM, frmBitmaps[X_GLOW]];

          tImages[IMG_Q_NORM]:
            intArr := [IMG_Q_NORM, frmBitmaps[Q_GLOW]];

          tImages[IMG_STRT_NORM]:
            intArr := [IMG_STRT_NORM, frmBitmaps[STRT_GLOW]];

          tImages[IMG_CRDTS_NORM]:
            intArr := [IMG_CRDTS_NORM, frmBitmaps[CRDTS_GLOW]];

          tImages[IMG_X_SML]:
            intArr := [IMG_X_SML, frmBitmaps[X_SML_GLOW]];

          tImages[IMG_Q_SND]:
            intArr := [IMG_Q_SND, frmBitmaps[Q_NORM_LBL]];

          tImages[IMG_Q_BRK]:
            intArr := [IMG_Q_BRK, frmBitmaps[Q_NORM_LBL]];

          tImages[IMG_CLOSE]:
            intArr := [IMG_CLOSE, frmBitmaps[CLOSE_GLOW]];

          tImages[IMG_TAB_ADD_NORM]:
            intArr := [IMG_TAB_ADD_NORM, frmBitmaps[TAB_ADD_GLOW]];

          tImages[IMG_TAB_DLT_NORM]:
            intArr := [IMG_TAB_DLT_NORM, frmBitmaps[TAB_DLT_GLOW]];

          else
            Exit;
        end;

        if (isActiveImage[intArr[0]]) then
          Exit;
        GetBitmapSize(intArr[1], w, h);
        {$ifdef Simba}
        DrawBitmap(intArr[1],tImages[intArr[0]].Canvas,0,0);
        {$else}
        SafeCopyCanvas(GetBitmapCanvas(intArr[1]), tImages[intArr[0]].Canvas,
                       0, 0, w, h, 0, 0, w, h);
        {$endif}
        isActiveImage[intArr[0]] := True;
      end;

    tImages[IMG_TAB_LABELS], tImages[IMG_TAB_SAVE_NORM], tImages[IMG_TAB_LOAD_NORM]:
      begin
        case Sender of
          tImages[IMG_TAB_LABELS]:
            begin
              bmpArr := [ TAB_SAVE_NORM, TAB_LOAD_NORM ];
              imgArr := [ IMG_TAB_SAVE_NORM, IMG_TAB_LOAD_NORM, IMG_TAB_LABELS ];
            end;

          tImages[IMG_TAB_SAVE_NORM]:
            begin
              bmpArr := [ TAB_SAVE_GLOW, TAB_LOAD_NORM ];
              imgArr := [ IMG_TAB_SAVE_NORM, IMG_TAB_LOAD_NORM, IMG_TAB_SAVE_NORM ];
            end;

          tImages[IMG_TAB_LOAD_NORM]:
            begin
              bmpArr := [ TAB_LOAD_GLOW, TAB_SAVE_NORM ];
              imgArr := [ IMG_TAB_LOAD_NORM, IMG_TAB_SAVE_NORM, IMG_TAB_LOAD_NORM ];
            end;
        end;

        for i := 0 to 1 do
        begin
          if (not isActiveImage[imgArr[i]]) then
            Continue;

          bmp := frmBitmaps[bmpArr[i]];
          GetBitmapSize(bmp, w, h);
          {$ifdef Simba}
          DrawBitmap(bmp,tImages[imgArr[i]].Canvas,0,0);
          {$else}
          SafeCopyCanvas(GetBitmapCanvas(bmp), tImages[imgArr[i]].Canvas,
                         0, 0, w, h, 0, 0, w, h);
          {$endif}
          if (Sender = tImages[IMG_TAB_LABELS]) then
          begin
            isActiveImage[imgArr[i]] := False;
          end;
        end;

        isActiveImage[imgArr[2]] := True;
      end;

    else begin
      frm_Debug('frm_OnMouseMove', 'Invalid Sender!');
      Exit;
    end;
  end;
end;

procedure frm_InitForm;
var
  mainImage, mainCombo, mainEdit, helpImage, introImage, tabCombo, tabEdit: Integer;
  bmp, hi, h, i, w: Integer;
  bmpArr: Array [0..BITMAP_COUNT - 1] of String;
  comboItems: TStringArray;
  intArr: TIntegerArray;
begin
  bmpArr[BGND]   := 'BGND.png';   bmpArr[Q_NORM_LBL] := 'Q_NORM_LBL.png';
  bmpArr[INTRO]  := 'INTRO.png';  bmpArr[Q_GLOW_LBL] := 'Q_GLOW_LBL.png';
  bmpArr[X_NORM] := 'X_NORM.png'; bmpArr[STRT_NORM]  := 'STRT_NORM.png';
  bmpArr[X_GLOW] := 'X_GLOW.png'; bmpArr[STRT_GLOW]  := 'STRT_GLOW.png';
  bmpArr[Q_NORM] := 'Q_NORM.png'; bmpArr[SCPT_HEAD]  := 'SCPT_HEAD.png';
  bmpArr[Q_GLOW] := 'Q_GLOW.png'; bmpArr[SCPT_OTHR]  := 'SCPT_HEAD_OTHR.png';

  bmpArr[OTHR_LBL] := 'OTHR_LBL.png'; bmpArr[REQUIRED] := 'REQUIRED.png';
  bmpArr[SMRT_LBL] := 'SMRT_LBL.png'; bmpArr[SMRT_USE] := 'SMRT_USE.png';
  bmpArr[STAT_LBL] := 'STAT_LBL.png'; bmpArr[CLOSE_NORM] := 'CLOSE_NORM.png';
  bmpArr[FRM_HELP] := 'FRM_HELP.png'; bmpArr[CLOSE_GLOW] := 'CLOSE_GLOW.png';

  bmpArr[TAB_SCPT_NORM] := 'TAB_SCPT.png';     bmpArr[TAB_SAVE_NORM] := 'TAB_SAVE_NORM.png';
  bmpArr[TAB_SCPT_DRK]  := 'TAB_SCPT_DRK.png'; bmpArr[TAB_SAVE_GLOW] := 'TAB_SAVE_GLOW.png';
  bmpArr[TAB_PLR_DRK]   := 'TAB_PLR_DRK.png';  bmpArr[TAB_LOAD_NORM] := 'TAB_LOAD_NORM.png';
  bmpArr[TAB_PLR_NORM]  := 'TAB_PLR.png';      bmpArr[TAB_LOAD_GLOW] := 'TAB_LOAD_GLOW.png';
  bmpArr[TAB_ADD_NORM]  := 'TAB_ADD_NORM.png'; bmpArr[FRM_CREDITS] := 'FRM_CREDITS.png';
  bmpArr[TAB_ADD_GLOW]  := 'TAB_ADD_GLOW.png';
  bmpArr[TAB_INACTIVE]  := 'TAB_INACTIVE.png';
  bmpArr[TAB_ACTIVE]    := 'TAB_ACTIVE.png';
  bmpArr[TAB_DLT_NORM]  := 'TAB_DLT_NORM.png';
  bmpArr[TAB_DLT_GLOW]  := 'TAB_DLT_GLOW.png';
  bmpArr[TAB_BDER]      := 'TAB_BDER.png';
  bmpArr[TAB_LABELS]    := 'TAB_LABELS.png';

  bmpArr[X_SML_NORM] := 'X_SML_NORM.png'; bmpArr[CRDTS_NORM] := 'CRDTS_NORM.png';
  bmpArr[X_SML_GLOW] := 'X_SML_GLOW.png'; bmpArr[CRDTS_GLOW] := 'CRDTS_GLOW.png';

  hi := High(frmBitmaps);
  for i := 0 to hi do
    frmBitmaps[i] := LoadBitmap(ScriptPath + 'Bitmaps\' + bmpArr[i]);
  {
    Everything to do with the main form (frmMain) begins here.
  }
  frmMain := CreateForm;
  with frmMain do
  begin
    SetBounds({L} 100, {T} 100, {W} 555, {H} 433);
    BorderStyle := bsNone;
  end;

  useSmart := TCheckBox.Create(frmMain);
  with useSmart do
  begin
    Parent := frmMain;
    SetBounds({L} 73, {T} 319, {W} 20, {H} 20);
    OnClick := @frm_OnClick;
  end;

  for mainImage := 0 to IMG_TAB_LOAD_NORM do
  begin
    tImages[mainImage] := TImage.Create(frmMain);
    with tImages[mainImage] do
    begin
      Parent := frmMain;

      case mainImage of
        IMG_BGND:
          begin
            SetBounds({L} 0, {T} 0, {W} 555, {H} 433);
            bmp := frmBitmaps[BGND];
            OnMouseMove := @frm_OnMouseMove;
            isActiveImage[IMG_BGND] := False;
          end;

        IMG_X_NORM:
          begin
            SetBounds({L} 518, {T} 7, {W} 28, {H} 34);
            bmp := frmBitmaps[X_NORM];
            OnMouseMove := @frm_OnMouseMove;
            OnClick := @frm_OnClick;
            isActiveImage[IMG_X_NORM] := False;
          end;

        IMG_Q_NORM:
          begin
            SetBounds({L} 518, {T} 390, {W} 28, {H} 33);
            bmp := frmBitmaps[Q_NORM];
            OnMouseMove := @frm_OnMouseMove;
            OnClick := @frm_OnClick;
            isActiveImage[IMG_Q_NORM] := False;
          end;

        IMG_STRT_NORM:
          begin
            SetBounds({L} 345, {T} 363, {W} 150, {H} 21);
            bmp := frmBitmaps[STRT_NORM];
            OnMouseMove := @frm_OnMouseMove;
            OnClick := @frm_OnClick;
            isActiveImage[IMG_STRT_NORM] := False;
          end;

        IMG_CRDTS_NORM:
          begin
            SetBounds({L} 157, {T} 363, {W} 150, {H} 21);
            bmp := frmBitmaps[CRDTS_NORM];
            OnClick := @frm_OnClick;
            OnMouseMove := @frm_OnMouseMove;
            isActiveImage[IMG_STRT_NORM] := False;
          end;

        IMG_TAB_PLR_DRK:
          begin
            SetBounds({L} 276, {T} 133, {W} 217, {H} 26);
            bmp := frmBitmaps[TAB_PLR_DRK];
            OnClick := @frm_OnClick;
            isActiveImage[IMG_TAB_PLR_DRK] := False;
          end;

        IMG_TAB_SCPT_NORM:
          begin
            SetBounds({L} 59, {T} 133, {W} 217, {H} 26);
            bmp := frmBitmaps[TAB_SCPT_NORM];
            OnClick := @frm_OnClick;
            isActiveImage[IMG_TAB_SCPT_NORM] := True;
          end;

        IMG_SCPT_HEAD:
          begin
            SetBounds({L} 85, {T} 159, {W}381, {H}25);
            bmp := frmBitmaps[SCPT_HEAD];
            isActiveImage[IMG_SCPT_HEAD] := False;
          end;

        IMG_SCPT_OTHR:
          begin
            SetBounds({L} 313, {T} 252, {W} 154, {H} 24);
            bmp := frmBitmaps[SCPT_OTHR];
            isActiveImage[IMG_SCPT_OTHR] := False;
          end;

        IMG_SMRT_USE:
          begin
            SetBounds({L} 88, {T} 319, {W} 177, {H} 23);
            bmp := frmBitmaps[SMRT_USE];
          end;

        IMG_SMRT_LBL:
          begin
            SetBounds({L} 60, {T} 187, {W} 105, {H} 120);
            bmp := frmBitmaps[SMRT_LBL];
            isActiveImage[IMG_SMRT_LBL] := False;
          end;

        IMG_STAT_LBL:
          begin
            SetBounds({L} 295, {T} 189, {W} 66, {H} 54);
            bmp := frmBitmaps[STAT_LBL];
            isActiveImage[IMG_STAT_LBL] := False;
          end;

        IMG_OTHR_LBL:
          begin
            SetBounds({L} 295, {T} 285, {W} 79, {H} 55);
            bmp := frmBitmaps[OTHR_LBL];
            isActiveImage[IMG_OTHR_LBL] := False;
          end;

        IMG_Q_SND, IMG_Q_BRK:
          begin
            if (mainImage = IMG_Q_BRK) then
              SetBounds({L} 488, {T} 319, {W} 16, {H} 19)
            else
              SetBounds({L} 488, {T} 287, {W} 16, {H} 19);

            bmp := frmBitmaps[Q_GLOW_LBL];
            OnMouseMove := @frm_OnMouseMove;
            OnClick := @frm_OnClick;
            isActiveImage[mainImage] := False;
          end;

        IMG_TAB_BDER:
          begin
            SetBounds({L} 38, {T} 178, {W} 478, {H} 7);
            bmp := frmBitmaps[TAB_BDER];
            Visible := False;
            isActiveImage[IMG_TAB_BDER] := False;
          end;

        IMG_TAB_LABELS:
          begin
            SetBounds({L} 50, {T} 194, {W} 340, {H} 151);
            bmp := frmBitmaps[TAB_LABELS];
            OnMouseMove := @frm_OnMouseMove;
            Visible := False;
            isActiveImage[IMG_TAB_LABELS] := False;
          end;

        IMG_TAB_ADD_NORM, IMG_TAB_DLT_NORM, IMG_TAB_SAVE_NORM, IMG_TAB_LOAD_NORM:
          begin
            case mainImage of
              IMG_TAB_ADD_NORM:
                begin
                  SetBounds({L} 127, {T} 165, {W} 7, {H} 7);
                  intArr := [TAB_ADD_NORM, IMG_TAB_ADD_NORM];
                  OnClick := @frm_OnClick;
                end;

              IMG_TAB_DLT_NORM:
                begin
                  SetBounds({L} 127, {T} 166, {W} 5, {H} 5);
                  intArr := [TAB_DLT_NORM, IMG_TAB_ADD_NORM];
                  OnClick := @frm_OnClick;
                end;

              IMG_TAB_SAVE_NORM:
                begin
                  SetBounds({L} 279, {T} 320, {W} 93, {H} 20);
                  intArr := [TAB_SAVE_NORM, IMG_TAB_SAVE_NORM];
                  OnClick := @frm_SavePlayers;
                end;

              IMG_TAB_LOAD_NORM:
                begin
                  SetBounds({L} 395, {T} 321, {W} 94, {H} 19);
                  intArr := [TAB_LOAD_NORM, IMG_TAB_LOAD_NORM];
                  OnClick := @frm_LoadPlayers;
                end;
            end;

            bmp := frmBitmaps[intArr[0]];
            Visible := False;
            OnMouseMove := @frm_OnMouseMove;
            isActiveImage[intArr[1]] := False;
          end;


        IMG_REQUIRED:
          begin
            SetBounds({L} 50, {T} 363, {W} 81, {H} 22);
            bmp := frmBitmaps[REQUIRED];
          end;

        else begin
          frm_Debug('frm_InitForm', 'Invalid mainImage!');
          Exit;
        end;
      end;

      GetBitmapSize(bmp, w, h);
      {$ifdef Simba}
      DrawBitmap(bmp,Canvas,0,0);
      {$else}
      SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas, 0, 0, w, h, 0, 0, w, h);
      {$endif}
    end;
  end;

  hi := High(tCombos);
  for mainCombo := 0 to hi do
  begin
    tCombos[mainCombo] := TComboBox.Create(frmMain);
    with tCombos[mainCombo] do
    begin
      Parent := frmMain;
      Color  := 5334130;
      Font.Color := clWhite;
      Font.Name  := 'Courier New';
      OnKeyPress := @frm_OnKeyPress;

      case mainCombo of
        BOX_SND:
          begin
            SetBounds({L} 382, {T} 285, {W} 100, {H} 20);
            MaxLength := 3;
            comboItems := ['Yes', 'No'];

            if (FileExists(ScriptPath + 'DCnB_PlayerList')) then
              Text := ReadINI('Setup Info', 'Play Sound', ScriptPath + 'DCnB_PlayerList');
          end;

        BOX_SMRT_MEM..BOX_SMRT_CLNT:
          begin
            SetBounds({L} 175, {T} 221 + (mainCombo * 32), {W} 100, {H} 20);

            case mainCombo of
              BOX_SMRT_MEM:
                begin
                  comboItems := ['Free', 'Members'];
                  Text := 'Free';
                end;

              BOX_SMRT_DTL:
                begin
                  comboItems := ['Low', 'High'];
                  Text := 'Low';
                end;

              BOX_SMRT_CLNT:
                begin
                  comboItems := ['Signed', 'Unsigned'];
                  Text := 'Signed';
                end;
            end;
          end;
        else begin
          frm_Debug('frm_InitForm', 'Invalid mainCombo!');
          Exit;
        end;
      end;

      for i := 0 to High(comboItems) do
        Items.Add(comboItems[i]);
    end;
  end;

  hi := High(tEdits);
  for mainEdit := 0 to hi do
  begin
    tEdits[mainEdit] := TEdit.Create(frmMain);
    with tEdits[mainEdit] do
    begin
      Parent := frmMain;
      Color  := 5334130;
      Font.Color := clWhite;
      Font.Name  := 'Courier New';

      case mainEdit of
        EDIT_SMRT_WLD:
          begin
            SetBounds({L} 175, {T} 189, {W} 100, {H} 20);
            Text := '152';
            MaxLength := 3;
          end;

        EDIT_STAT_ID, EDIT_STAT_PASS:
          begin
            SetBounds({L} 382, {T} 157 + (mainEdit * 32), {W} 100, {H} 20);

            if (mainEdit = EDIT_STAT_PASS) then
            begin
              PasswordChar := '*';
              if (FileExists(ScriptPath + 'DCnB_PlayerList')) then
                Text := ReadINI('Setup Info', 'Stats Pass', ScriptPath + 'DCnB_PlayerList');
            end else
              if (FileExists(ScriptPath + 'DCnB_PlayerList')) then
                Text := ReadINI('Setup Info', 'Stats ID', ScriptPath + 'DCnB_PlayerList');
          end;

        EDIT_BRK_AFTER:
          begin
            SetBounds({L} 382, {T} 317, {W} 100, {H} 20);
            if (FileExists(ScriptPath + 'DCnB_PlayerList')) then
              Text := ReadINI('Setup Info', 'Break After', ScriptPath + 'DCnB_PlayerList');
          end;

        else begin
          frm_Debug('frm_InitForm', 'Invalid mainEdit!');
          Exit;
        end;
      end;
    end;
  end;
  {
    Everything to do with the main form (frmMain) ends here, and everything to
    do with the help form (frmHelp) starts here.
  }
  frmHelp := CreateForm;
  with frmHelp do
  begin
    SetBounds({L} Round(frmMain.Left + (frmMain.Width div 2) - (259 div 2)),
              {T} Round(frmMain.Top + (frmMain.Height div 2) - (105 div 2)),
              {W} 259, {H} 105);
    BorderStyle := bsNone;
    Visible := False;
  end;

  for helpImage := IMG_FRM_HELP to IMG_X_SML do
  begin
    tImages[helpImage] := TImage.Create(frmHelp);
    with tImages[helpImage] do
    begin
      Parent := frmHelp;

      case helpImage of
        IMG_FRM_HELP:
          begin
            SetBounds({L} 0, {T} 0, {W} 259, {H} 105);
            bmp := frmBitmaps[FRM_HELP];
          end;

        IMG_X_SML:
          begin
            SetBounds({L} 236, {T} 3, {W} 16, {H} 16);
            bmp := frmBitmaps[X_SML_NORM];
            OnClick := @frm_OnClick;
          end;

        else begin
          frm_Debug('frm_InitForm', 'Invalid helpImage!');
          Exit;
        end;
      end;

      isActiveImage[helpImage] := False;
      OnMouseMove := @frm_OnMouseMove;
      GetBitmapSize(bmp, w, h);
      {$ifdef Simba}
      DrawBitmap(bmp,Canvas,0,0);
      {$else}
      SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas, 0, 0, w, h, 0, 0, w, h);
      {$endif}
    end;
  end;
  {
    Everything to do with the help form (frmHelp) ends here, and everything to
    do with the introduntion form (frmIntro) and the credits form (frmCredits)
    starts here.
  }
  frmIntro := CreateForm;
  with frmIntro do
  begin
    SetBounds({L} frmMain.Left + 34, {T} frmMain.Top + 43, {W} 486, {H} 345);
    BorderStyle := bsNone;
    Visible := False;
  end;

  for introImage := IMG_FRM_INTRO to IMG_CLOSE do
  begin
    tImages[introImage] := TImage.Create(frmIntro);
    with tImages[introImage] do
    begin


      case introImage of
        IMG_FRM_INTRO:
          begin
            Parent := frmIntro;
            SetBounds({L} 0, {T} 0, {W} 486, {H} 345);
            bmp := frmBitmaps[INTRO];
          end;

        IMG_CLOSE:
          begin
            SetBounds({L} 423, {T} 16, {W} 23, {H} 11);
            bmp := frmBitmaps[CLOSE_NORM];
            OnClick := @frm_OnClick;
            Visible := False;
          end;

        else begin
          frm_Debug('frm_InitForm', 'Invalid introImage!');
          Exit;
        end;
      end;

      isActiveImage[introImage] := False;
      OnMouseMove := @frm_OnMouseMove;
      GetBitmapSize(bmp, w, h);
      {$ifdef Simba}
      DrawBitmap(bmp,Canvas,0,0);
      {$else}
      SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas, 0, 0, w, h, 0, 0, w, h);
      {$endif}
    end;
  end;

  frmCredits := CreateForm;
  with frmCredits do
  begin
    SetBounds({L} frmMain.Left + 34, {T} frmMain.Top + 43, {W} 486, {H} 345);
    BorderStyle := bsNone;
    Visible := False;
  end;

  tImages[IMG_FRM_CREDITS] := TImage.Create(frmCredits);
  with tImages[IMG_FRM_CREDITS] do
  begin
    Parent := frmCredits;
    SetBounds({L} 0, {T} 0, {W} 486, {H} 345);
    bmp := frmBitmaps[FRM_CREDITS];

    isActiveImage[IMG_FRM_CREDITS] := False;
    OnMouseMove := @frm_OnMouseMove;
    GetBitmapSize(bmp, w, h);
    {$ifdef Simba}
    DrawBitmap(bmp,Canvas,0,0);
    {$else}
    SafeCopyCanvas(GetBitmapCanvas(bmp), Canvas, 0, 0, w, h, 0, 0, w, h);
    {$endif}
  end;
  {
    Everything to do with the intro form (frmIntro) ends here, and everything
    to do with the tabs starts here.
  }
  tab_CreateObject(TAB_TABS, False);
  tab_CreateObject(TAB_LABEL, False);

  hi := High(tTabCombos);
  for tabCombo := 0 to hi do
  begin
    tTabCombos[tabCombo] := TComboBox.Create(frmMain);
    with tTabCombos[tabCombo] do
    begin
      Parent := frmMain;
      Color  := 5334130;
      Font.Color := clWhite;
      Font.Name  := 'Courier New';
      OnKeyPress := @frm_OnKeyPress;

      if (isActiveImage[IMG_TAB_SCPT_NORM]) then
        Visible := False
      else
        Visible := True;

      case tabCombo of
        BOX_ACTIVE:
          begin
            SetBounds({L} 152, {T} 319, {W} 100, {H} 20);
            comboItems := ['Yes', 'No'];
          end;

        BOX_TREE:
          begin
            SetBounds({L} 395, {T} 195, {W} 100, {H} 20);
            comboItems := ['Willow', 'Oak'];
          end;

        BOX_HATCHET:
          begin
            SetBounds({L} 395, {T} 257, {W} 100, {H} 20);
            comboItems := ['Equipped', 'Inventory'];
          end;

        BOX_BREAKS:
          begin
            SetBounds({L} 395, {T} 288, {W} 100, {H} 20);
            comboItems := ['Yes', 'No'];
          end;

        else begin
          frm_Debug('frm_InitForm', 'Invalid tabComboBox!');
          Exit;
        end;
      end;

      for i := 0 to High(comboItems) do
        Items.Add(comboItems[i]);
    end;
  end;

  hi := High(tTabEdits);
  for tabEdit := 0 to hi do
  begin
    tTabEdits[tabEdit] := TEdit.Create(frmMain);
    with tTabEdits[tabEdit] do
    begin
      Parent := frmMain;
      Color  := 5334130;
      Font.Color := clWhite;
      Font.Name  := 'Courier New';

      if (isActiveImage[IMG_TAB_SCPT_NORM]) then
        Visible := False
      else
        Visible := True;

      case tabEdit of
        EDIT_NAME, EDIT_PASS, EDIT_NICK, EDIT_PIN:
          begin
            if (tabEdit = EDIT_PASS) or (tabEdit = EDIT_PIN) then
              tTabEdits[tabEdit].PasswordChar := '*';

            if (tabEdit = EDIT_PIN) or (tabEdit = EDIT_NICK) then
              MaxLength := 4;

            SetBounds({L} 152, {T} 195 + (tabEdit * 31), {W} 100, {H} 20);
          end;

        EDIT_LOGS:
          SetBounds({L} 395, {T} 226, {W} 100, {H} 20);

        else begin
          frm_Debug('frm_InitForm', 'Invalid tabEditBox!');
          Exit;
        end;
      end;
    end;
  end;

  frm_PlayerInfo(0, False);
  {
    Everything to do with the tabs ends here.
  }
end;

procedure frm_SafeInitForm;
var
  varArr: TVariantArray;
begin
  SetArrayLength(varArr, 0);
  ThreadSafeCall('frm_InitForm', varArr);
end;

procedure frm_ShowFormModal;
begin
  frmMain.ShowModal;
end;

procedure frm_SafeShowFormModal;
var
  varArr: TVariantArray;
begin
  SetArrayLength(varArr, 0);
  ThreadSafeCall('frm_ShowFormModal', varArr);
end;

procedure frm_KillForm;
var
  i: Integer;
begin
  for i := 0 to BITMAP_COUNT - 1 do
    FreeBitmap(frmBitmaps[i]);

  for i := IMG_COUNT - 1 downto 0 do
    try
      tImages[i].Free;
    except
      frm_Debug('frm_KillForm', 'Image[' + IntToStr(i) + '] was not freed.');
    end;

  FreeForm(frmMain);
  FreeForm(frmHelp);
  FreeForm(frmIntro);
end;

procedure frm_ShowPlayerForm;
begin
  frm_SafeInitForm;
  frm_SafeShowFormModal;
end;
